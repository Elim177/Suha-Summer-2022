[{"items": [{"tags": ["python", "tensorflow", "neural-network", "deep-learning", "feature-extraction"], "owner": {"user_type": "does_not_exist", "display_name": "user1711524"}, "is_answered": false, "view_count": 326, "answer_count": 0, "score": 1, "last_activity_date": 1486553627, "creation_date": 1486547310, "last_edit_date": 1486553627, "question_id": 42109668, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/42109668/feature-representation-using-cnn-image-aesthetics", "title": "Feature Representation using CNN (Image Aesthetics)", "body": "<p>I'm new to TensorFlow and i was able to use the below mentioned program for image classification. As Convolutional neural networks are arranged in layers, and each different layer captures information of a different kind. The first layers, which are close to the input, usually detect low-level information and deeper layers extract richer information. </p>\n\n<p>Now, my <strong>objective</strong> is to compare images and learn the commonalities and differences between three images, that is, i want to learn a feature representation (say D) such as for 3 images (say I1,I2 and I3 - where I1 &amp; I2 are aesthetically pleasing and I3 is not)</p>\n\n<pre><code>Distance(D(I1), D(I2)) &lt; Distance(D(I1), D(I3))\n</code></pre>\n\n<p>What i figured out from this is pixel correlation plays an important role (correct me if i'm wrong).</p>\n\n<p><strong>How can i achieve this? What are the steps involved in this process?</strong> </p>\n\n<p><em>Code for Image Classification:</em></p>\n\n<pre><code>import tensorflow as tf\n\nimport numpy as np\nfrom scipy.misc import imread, imresize\n\n\nclass vgg16:\n    def __init__(self, imgs, weights=None, sess=None):\n        self.imgs = imgs\n        self.convlayers()\n        self.fc_layers()\n        self.probs = tf.nn.softmax(self.fc3l)\n        if weights is not None and sess is not None:\n            self.load_weights(weights, sess)\n\n\n    def convlayers(self):\n        self.parameters = []\n\n        # zero-mean input\n        with tf.name_scope('preprocess') as scope:\n            mean = tf.constant([123.68, 116.779, 103.939], dtype=tf.float32, shape=[1, 1, 1, 3], name='img_mean')\n            images = self.imgs-mean\n\n        # conv1_1\n        with tf.name_scope('conv1_1') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 3, 64], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(images, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[64], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv1_1 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n\n\n        # conv1_2\n        with tf.name_scope('conv1_2') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 64, 64], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv1_1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[64], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv1_2 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # pool1\n        self.pool1 = tf.nn.max_pool(self.conv1_2,\n                               ksize=[1, 2, 2, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='SAME',\n                               name='pool1')\n\n        # conv2_1\n        with tf.name_scope('conv2_1') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 64, 128], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.pool1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[128], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv2_1 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv2_2\n        with tf.name_scope('conv2_2') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 128, 128], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv2_1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[128], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv2_2 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # pool2\n        self.pool2 = tf.nn.max_pool(self.conv2_2,\n                               ksize=[1, 2, 2, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='SAME',\n                               name='pool2')\n\n        # conv3_1\n        with tf.name_scope('conv3_1') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 128, 256], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.pool2, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[256], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv3_1 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv3_2\n        with tf.name_scope('conv3_2') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 256, 256], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv3_1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[256], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv3_2 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv3_3\n        with tf.name_scope('conv3_3') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 256, 256], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv3_2, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[256], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv3_3 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # pool3\n        self.pool3 = tf.nn.max_pool(self.conv3_3,\n                               ksize=[1, 2, 2, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='SAME',\n                               name='pool3')\n\n        # conv4_1\n        with tf.name_scope('conv4_1') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 256, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.pool3, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv4_1 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv4_2\n        with tf.name_scope('conv4_2') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 512, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv4_1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv4_2 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv4_3\n        with tf.name_scope('conv4_3') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 512, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv4_2, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv4_3 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # pool4\n        self.pool4 = tf.nn.max_pool(self.conv4_3,\n                               ksize=[1, 2, 2, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='SAME',\n                               name='pool4')\n\n        # conv5_1\n        with tf.name_scope('conv5_1') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 512, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.pool4, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv5_1 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv5_2\n        with tf.name_scope('conv5_2') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 512, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv5_1, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv5_2 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # conv5_3\n        with tf.name_scope('conv5_3') as scope:\n            kernel = tf.Variable(tf.truncated_normal([3, 3, 512, 512], dtype=tf.float32,\n                                                     stddev=1e-1), name='weights')\n            conv = tf.nn.conv2d(self.conv5_2, kernel, [1, 1, 1, 1], padding='SAME')\n            biases = tf.Variable(tf.constant(0.0, shape=[512], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            out = tf.nn.bias_add(conv, biases)\n            self.conv5_3 = tf.nn.relu(out, name=scope)\n            self.parameters += [kernel, biases]\n\n        # pool5\n        self.pool5 = tf.nn.max_pool(self.conv5_3,\n                               ksize=[1, 2, 2, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='SAME',\n                               name='pool4')\n\n    def fc_layers(self):\n        # fc1\n        with tf.name_scope('fc1') as scope:\n            shape = int(np.prod(self.pool5.get_shape()[1:]))\n            fc1w = tf.Variable(tf.truncated_normal([shape, 4096],\n                                                         dtype=tf.float32,\n                                                         stddev=1e-1), name='weights')\n            fc1b = tf.Variable(tf.constant(1.0, shape=[4096], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            pool5_flat = tf.reshape(self.pool5, [-1, shape])\n            fc1l = tf.nn.bias_add(tf.matmul(pool5_flat, fc1w), fc1b)\n            self.fc1 = tf.nn.relu(fc1l)\n            self.parameters += [fc1w, fc1b]\n\n        # fc2\n        with tf.name_scope('fc2') as scope:\n            fc2w = tf.Variable(tf.truncated_normal([4096, 4096],\n                                                         dtype=tf.float32,\n                                                         stddev=1e-1), name='weights')\n            fc2b = tf.Variable(tf.constant(1.0, shape=[4096], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            fc2l = tf.nn.bias_add(tf.matmul(self.fc1, fc2w), fc2b)\n            self.fc2 = tf.nn.relu(fc2l)\n            self.parameters += [fc2w, fc2b]\n\n        # fc3\n        with tf.name_scope('fc3') as scope:\n            fc3w = tf.Variable(tf.truncated_normal([4096, 1000],\n                                                         dtype=tf.float32,\n                                                         stddev=1e-1), name='weights')\n            fc3b = tf.Variable(tf.constant(1.0, shape=[1000], dtype=tf.float32),\n                                 trainable=True, name='biases')\n            self.fc3l = tf.nn.bias_add(tf.matmul(self.fc2, fc3w), fc3b)\n            self.parameters += [fc3w, fc3b]\n\n    def load_weights(self, weight_file, sess):\n        weights = np.load(weight_file)\n        keys = sorted(weights.keys())\n        for i, k in enumerate(keys):\n            print (i, k, np.shape(weights[k]))\n            sess.run(self.parameters[i].assign(weights[k]))\n\nif __name__ == '__main__':\n    sess = tf.Session()\n    imgs = tf.placeholder(tf.float32, [None, 224, 224, 3])\n    vgg = vgg16(imgs, 'vgg16_weights.npz', sess)\n\n    img1 = imread('img.jpg', mode='RGB')\n    img1 = imresize(img1, (224, 224))\n\n    prob = sess.run(vgg.probs, feed_dict={vgg.imgs: [img1]})[0]\n    preds = (np.argsort(prob)[::-1])[0:5]\n    for p in preds:\n        print (class_names[p], prob[p])\n</code></pre>\n\n<p><em>More clarification:</em></p>\n\n<p>how to write the code? because the aim is to find a mathematical space in which the distance between the two images that are aesthetically pleasing is less than the distance between an aesthetically pleasing one and one which is not. I'm not able to compute that.</p>\n\n<p>Attributes to judge image aesthetics: interesting content, object emphasis, good lighting, color harmony, vivid color, shallow depth of f ield, motion blur, rule of thirds, balancing element, repetition, and symmetry.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 110}]