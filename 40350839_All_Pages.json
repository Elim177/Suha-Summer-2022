[{"items": [{"tags": ["python", "list", "numpy", "multidimensional-array", "tensorflow"], "owner": {"user_type": "does_not_exist", "display_name": "user6467981"}, "is_answered": true, "view_count": 7984, "accepted_answer_id": 40351338, "answer_count": 3, "score": 6, "last_activity_date": 1530283299, "creation_date": 1477949141, "question_id": 40350839, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/40350839/tensorflow-unhashable-type-list-in-sess-run", "title": "Tensorflow unhashable type &#39;list&#39; in sess.run", "body": "<p>There are literally thousands of these posts but I haven't seen one yet that addresses my exact problem. Please feel free to close this if one exists.</p>\n\n<p>I understand that lists are mutable in Python. As a result, we cannot store a list as a key in a dictionary.</p>\n\n<p>I have the following code (a ton of it is left out because it is irrelevant):</p>\n\n<pre><code>with tf.Session() as sess:\n    sess.run(init)\n    step = 1\n\n    while step * batch_size &lt; training_iterations:\n            for batch_x, batch_y in batch(train_x, train_y, batch_size):\n\n            batch_x = np.reshape(batch_x, (batch_x.shape[0],\n                                           1,\n                                           batch_x.shape[1]))\n            batch_x.astype(np.float32)\n\n            batch_y = np.reshape(batch_y, (batch_y.shape[0], 1))\n            batch_y.astype(np.float32)\n\n            sess.run(optimizer, feed_dict={x: batch_x, y: batch_y})\n            if step % display_step == 0:\n                # Calculate batch accuracy\n                acc = sess.run(accuracy,\n                               feed_dict={x: batch_x, y: batch_y})\n                # Calculate batch loss\n                loss = sess.run(cost, feed_dict={x: batch_x, y: batch_y})\n                print(\"Iter \" + str(step*batch_size) +\n                      \", Minibatch Loss= \" +\n                      \"{:.6f}\".format(loss) + \", Training Accuracy= \" +\n                      \"{:.5f}\".format(acc))\n        step += 1\n    print(\"Optimization Finished!\")\n</code></pre>\n\n<p><code>train_x</code> is a <code>[batch_size, num_features]</code> numpy matrix</p>\n\n<p><code>train_y</code> is a <code>[batch_size, num_results]</code> numpy matrix</p>\n\n<p>I have the following placeholders in my graph:</p>\n\n<pre><code>x = tf.placeholder(tf.float32, shape=(None, num_steps, num_input))\ny = tf.placeholder(tf.float32, shape=(None, num_res))\n</code></pre>\n\n<p>So naturally I need to transform my <code>train_x</code> and <code>train_y</code> to get to the correct format tensorflow expects.</p>\n\n<p>I do that with the following:</p>\n\n<pre><code> batch_x = np.reshape(batch_x, (batch_x.shape[0],\n                                1,\n                                batch_x.shape[1]))\n\n batch_y = np.reshape(batch_y, (batch_y.shape[0], 1))\n</code></pre>\n\n<p>This result gives me two <code>numpy.ndarray</code>:</p>\n\n<p><code>batch_x</code> is of dimensions <code>[batch_size, timesteps, features]</code>\n<code>batch_y</code> is of dimensions <code>[batch_size, num_results]</code></p>\n\n<p>As expected by our graph.</p>\n\n<p>Now when I pass these reshaped <code>numpy.ndarray</code> I get <code>TypeError: Unhashable type list</code> on the following line:</p>\n\n<pre><code>sess.run(optimizer, feed_dict={x: batch_x, y: batch_y})\n</code></pre>\n\n<p>This seems strange to me because firing up python:</p>\n\n<pre><code>import numpy as np\na = np.zeros((10,3,4))\n{a : 'test'}\nTypeError: unhashable type: 'numpy.ndarray`\n</code></pre>\n\n<p>You can see I get an entirely different error message.</p>\n\n<p>Further in my code I perform a series of transformations on the data:</p>\n\n<pre><code>x = tf.transpose(x, [1, 0, 2])\nx = tf.reshape(x, [-1, num_input])\nx = tf.split(0, num_steps, x)\n\n\nlstm_cell = rnn_cell.BasicLSTMCell(num_hidden, forget_bias=forget_bias)\noutputs, states = rnn.rnn(lstm_cell, x, dtype=tf.float32)\n</code></pre>\n\n<p>And the only place a list occurs is after slicing, which results in a <code>T</code> sized list of tensors that <code>rnn.rnn</code> expects.</p>\n\n<p>I am at a complete loss here. I feel like I'm staring right at the solution and I can't see it. Can anyone help me out here? </p>\n\n<p>Thank you!</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 299}]