[{"items": [{"tags": ["python", "tensorflow", "keras", "nlp", "tensorflow2.0"], "owner": {"account_id": 4179598, "reputation": 326, "user_id": 7636462, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/KfjtH.jpg?s=256&g=1", "display_name": "S. P", "link": "https://stackoverflow.com/users/7636462/s-p"}, "is_answered": false, "view_count": 70, "answer_count": 1, "score": 1, "last_activity_date": 1595128224, "creation_date": 1595048133, "last_edit_date": 1595128224, "question_id": 62964806, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/62964806/conditional-weighting-for-sparsecategoricalcrossentropy-in-tensorflow", "title": "Conditional weighting for SparseCategoricalCrossentropy in TensorFlow", "body": "<p>We are working on an extractive text summarization task in TensorFlow. We have been able to get a baseline model up and running. Now, to get a more holistic model what we want to do is to be able to compensate for the padded sequences and at the same time give more preference to the sequences that are summary candidates originally.</p>\n<p>Here's what we have done so far:</p>\n<pre class=\"lang-py prettyprint-override\"><code>loss_object = tf.keras.losses.SparseCategoricalCrossentropy(\n    from_logits=True, reduction='none')\n\ndef loss_function(real, pred):\n    # account for the padded sequences\n    mask = tf.math.logical_not(tf.math.equal(real, 0))\n    \n    # account for the summary tags\n    important_tags = tf.math.equal(real, 2)\n    \n    # calculate the original loss\n    loss_ = loss_object(real, pred)\n    \n    # compensation scheme\n    mask = tf.cast(mask, dtype=loss_.dtype)\n    important_tags = tf.cast(important_tags, dtype=loss_.dtype)\n    loss_ *= mask # for the padded values\n    loss_ = 3 * important_tags # for giving more weightage to the summary candidates\n\n    return tf.reduce_mean(loss_)\n</code></pre>\n<p>This results in the <em><strong>gradients not found error</strong></em>. Any directions to remedy the situation, in general, or even a better approach toward conditional weighting with <code>SparseCategoricalCrossentropy</code> would be helpful.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 100}]