[{"items": [{"tags": ["python", "tensorflow", "machine-learning"], "owner": {"account_id": 12340467, "reputation": 407, "user_id": 9003851, "user_type": "registered", "accept_rate": 75, "profile_image": "https://www.gravatar.com/avatar/d27cb314705244798c5b766dc80cfb39?s=256&d=identicon&r=PG&f=1", "display_name": "moumenShobakey", "link": "https://stackoverflow.com/users/9003851/moumenshobakey"}, "is_answered": false, "view_count": 39, "answer_count": 1, "score": -1, "last_activity_date": 1631435722, "creation_date": 1631434180, "last_edit_date": 1631434687, "question_id": 69149602, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/69149602/multiplying-a-tensor-by-a-scalar-gives-a-tensor-of-nans", "title": "Multiplying a tensor by a scalar gives a tensor of Nans", "body": "<p>I am new to tensorflow, i am trying to use Linear regression technique to train my module, but the function results a tensor of Nans! Here is the code</p>\n<p>That's how i read the dataset</p>\n<pre><code>train_x = np.asanyarray(df[['Fat']]).astype(np.float32)\ntrain_y = np.asanyarray(df[['Calories']]).astype(np.float32)\n</code></pre>\n<p>the weights initialization</p>\n<pre><code>a = tf.Variable(20.0)\nb = tf.Variable(10.0)\n</code></pre>\n<p>the linear regression function</p>\n<pre><code>@tf.function\ndef h(x):\ny = a*x +b\n\nreturn  y\n</code></pre>\n<p>the cost function</p>\n<pre><code>@tf.function\ndef costFunc(y_predicted,train_y):\nreturn tf.reduce_mean(tf.square(y_predicted-train_y))\n</code></pre>\n<p>the module training</p>\n<pre><code>learning_rate = 0.01\ntrain_data = []\nloss_values =[]\na_values = []\nb_values = []\n# steps of looping through all your data to update the parameters\ntraining_epochs = 200\n</code></pre>\n<p>train model</p>\n<pre><code>for epoch in range(training_epochs):\n   with tf.GradientTape() as tape:\n       y_predicted = h(train_x)\n       loss_value = loss_object(train_y,y_predicted)\n       loss_values.append(loss_value)\n\n       get gradients\n       gradients = tape.gradient(loss_value, [b,a])\n    \n    #  compute and adjust weights\n       a_values.append(a.numpy())\n       b_values.append(b.numpy())\n       b.assign_sub(gradients[0]*learning_rate)\n       a.assign_sub(gradients[1]*learning_rate)\n       if epoch % 5 == 0:\n           train_data.append([a.numpy(), b.numpy()])\n</code></pre>\n<p>but when i print (a*train_x) the result is Nans tensor</p>\n<p>UPDATE\nI found that the problem is in the dataset, when i changed the dataset it gives tensor of numbers, but i still don't know what is the problem with the first dataset</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 27}]