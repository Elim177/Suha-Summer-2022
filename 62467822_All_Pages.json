[{"items": [{"tags": ["python", "tensorflow", "conv-neural-network", "convolution"], "owner": {"account_id": 7846906, "reputation": 2937, "user_id": 5931672, "user_type": "registered", "accept_rate": 86, "profile_image": "https://lh5.googleusercontent.com/-Ljkm-NVRzOc/AAAAAAAAAAI/AAAAAAAAAFE/EelBBzc8ji0/photo.jpg?sz=256", "display_name": "Agustin Barrachina", "link": "https://stackoverflow.com/users/5931672/agustin-barrachina"}, "is_answered": true, "view_count": 156, "accepted_answer_id": 62518596, "answer_count": 1, "score": 1, "last_activity_date": 1592841581, "creation_date": 1592560874, "question_id": 62467822, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/62467822/implement-convnd-in-tensorflow", "title": "Implement ConvND in Tensorflow", "body": "<p>So I need a ND convolutional layer that also supports complex numbers. So I decided to code it myself. </p>\n\n<p>I tested this code on numpy alone and it worked. Tested with several channels, 2D and 1D and complex. However, I have problems when I do it on TF.</p>\n\n<p>This is my code so far:</p>\n\n<pre><code>def call(self, inputs):\n    with tf.name_scope(\"ComplexConvolution_\" + str(self.layer_number)) as scope:\n        inputs = self._verify_inputs(inputs)            # Check inputs are of expected shape and format\n        inputs = self.apply_padding(inputs)             # Add zeros if needed\n        output_np = np.zeros(                           # I use np because tf does not support the assigment\n            (inputs.shape[0],) +                        # Per each image\n            self.output_size,                           # Image out size\n            dtype=self.input_dtype                      # To support complex numbers\n        )\n        img_index = 0\n        for image in inputs:\n            for filter_index in range(self.filters):\n                for i in range(int(np.prod(self.output_size[:-1]))):  # for each element in the output\n                    index = np.unravel_index(i, self.output_size[:-1])\n                    start_index = tuple([a * b for a, b in zip(index, self.stride_shape)])\n                    end_index = tuple([a+b for a, b in zip(start_index, self.kernel_shape)])\n                    # set_trace()\n                    sector_slice = tuple(\n                        [slice(start_index[ind], end_index[ind]) for ind in range(len(start_index))]\n                    )\n                    sector = image[sector_slice]\n                    new_value = tf.reduce_sum(sector * self.kernels[filter_index]) + self.bias[filter_index]\n                    # I use Tied Bias https://datascience.stackexchange.com/a/37748/75968\n                    output_np[img_index][index][filter_index] = new_value  # The complicated line\n                    img_index += 1\n        output = apply_activation(self.activation, output_np)\n    return output\n</code></pre>\n\n<p><code>input_size</code> is a tuple of shape (dim1, dim2, ..., dim3, channels). An 2D rgb conv for example will be (32, 32, 3) and <code>inputs</code> will have shape (None, 32, 32, 3).</p>\n\n<p>The output size is calculated from an equation I found in this paper: <a href=\"https://arxiv.org/abs/1603.07285\" rel=\"nofollow noreferrer\">A guide to convolution arithmetic for deep learning</a></p>\n\n<pre><code>out_list = []\nfor i in range(len(self.input_size) - 1):   # -1 because the number of input channels is irrelevant\n    out_list.append(int(np.floor((self.input_size[i] + 2 * self.padding_shape[i] - self.kernel_shape[i]) / self.stride_shape[i]) + 1))\nout_list.append(self.filters)\n</code></pre>\n\n<p>Basically, I use <code>np.zeros</code> because if I use <code>tf.zeros</code> I cannot assign the <code>new_value</code> and I get:\n<code>TypeError: 'Tensor' object does not support item assignment</code></p>\n\n<p>However, in this current state I am getting:<br>\n<code>NotImplementedError: Cannot convert a symbolic Tensor (placeholder_1:0) to a numpy array.</code></p>\n\n<p>On that same assignment. I don't see an easy fix, I think I should change the strategy of the code completely.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 221}]