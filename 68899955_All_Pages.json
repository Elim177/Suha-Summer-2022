[{"items": [{"tags": ["python", "tensorflow", "machine-learning", "keras", "deep-learning"], "owner": {"account_id": 11098615, "reputation": 5, "user_id": 8147960, "user_type": "registered", "profile_image": "https://lh4.googleusercontent.com/-DE1G4sCaWrQ/AAAAAAAAAAI/AAAAAAAAABU/OtcuTtqxIlY/photo.jpg?sz=256", "display_name": "Sher Khan Mari", "link": "https://stackoverflow.com/users/8147960/sher-khan-mari"}, "is_answered": true, "view_count": 725, "accepted_answer_id": 68991173, "answer_count": 1, "score": 0, "last_activity_date": 1632077525, "creation_date": 1629759764, "last_edit_date": 1629796867, "question_id": 68899955, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/68899955/loading-keras-model-typeerror-module-object-is-not-callable", "title": "loading keras model, TypeError: &#39;module&#39; object is not callable", "body": "<p>I have searched through stackoverflow and read through documentation but somehow still my trained model is not being loaded!\nI have checked following links and many more so please do not mark as duplicate straight away. thank you</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/42763094/how-to-save-final-model-using-keras\">How to save final model using keras?</a></li>\n<li><a href=\"https://www.tensorflow.org/guide/keras/save_and_serialize\" rel=\"nofollow noreferrer\">https://www.tensorflow.org/guide/keras/save_and_serialize</a></li>\n<li><a href=\"https://www.tensorflow.org/tutorials/distribute/save_and_load\" rel=\"nofollow noreferrer\">https://www.tensorflow.org/tutorials/distribute/save_and_load</a></li>\n<li><a href=\"https://www.tensorflow.org/guide/keras/functional\" rel=\"nofollow noreferrer\">https://www.tensorflow.org/guide/keras/functional</a></li>\n<li><a href=\"https://stackoverflow.com/questions/35074549/how-to-load-a-model-from-an-hdf5-file-in-keras\">How to load a model from an HDF5 file in Keras?</a></li>\n</ol>\n<p>here is my model:</p>\n<pre><code>def get_model(train=True):\n    \n    set_seed(33)\n    \n    pre_process = Lambda(preprocess_input)\n    vgg = VGG16(weights = 'imagenet', include_top = True, input_shape = SHAPE)\n    vgg = Model(vgg.input, vgg.layers[-3].output)\n    vgg.trainable = False\n    \n    inp = Input(SHAPE)\n    vgg_16_process = pre_process(GaussianNoise(0.1)(inp))\n    vgg_out = vgg(vgg_16_process)\n    \n    noise = Lambda(tf.zeros_like)(vgg_out)\n    noise = GaussianNoise(0.1)(noise)\n\n    if train:\n        x = Lambda(lambda z: tf.concat(z, axis=0))([vgg_out,noise])\n        x = Activation('relu')(x)\n    else:\n        x = vgg_out\n        \n    x = Dense(512, activation='relu')(x)\n    x = Dense(128, activation='relu')(x)\n    out = Dense(2, activation='softmax')(x)\n\n    model = Model(inp, out)\n    model.compile(Adam(learning_rate=1e-4), loss='binary_crossentropy')\n    \n    return model\n</code></pre>\n<p>And After that I have some test and train generator as follows,\nThe dataset is classical dog-vs-cat dataset and I'm trying to achieve one-class classification task.</p>\n<pre><code>\ntrain_datagen = ImageDataGenerator()\ntest_datagen = ImageDataGenerator()\n\ntrain_generator = train_datagen.flow_from_directory(\n            base_path + 'training_set/training_set/',\n            target_size = (SHAPE[0], SHAPE[1]),\n            batch_size = batch_size,\n            class_mode = 'categorical',\n            shuffle = True,\n            seed = 33,\n            classes = ['cats']\n    )\n\ntest_generator = test_datagen.flow_from_directory(\n            base_path + 'test_set/test_set/',\n            target_size = (SHAPE[0], SHAPE[1]),\n            batch_size = batch_size,\n            class_mode = 'categorical',\n            shuffle = True,\n            seed = 33,\n            classes = ['dogs','cats']\n)\n</code></pre>\n<p>Then finally, I do compile the model</p>\n<pre><code>model = get_model()\nmodel.fit(wrap_generator(train_generator), steps_per_epoch=train_generator.samples/train_generator.batch_size, epochs=1)\n</code></pre>\n<p>Then I do save model as follow</p>\n<pre><code>model.save('my_custom_model')\n</code></pre>\n<p>Either I do save in that format or 'my_custom_model.h5' it saves perfectly without any error.\nIf I use just save, then a folder is created with 'assets, variables, .pb files' that is expected as mentioned in posts of stackoverflow.</p>\n<p>** Then here comes the problem **</p>\n<pre><code>from keras.models import load_model\nloaded_model = load_model('my_custom_model.h5')\n#or \nloaded_model = tf.keras.models.load_model('my_custom_model.h5')\n#or \nloaded_model = load_model('my_custom_model') # as from folder\n\n</code></pre>\n<p>All throw same error</p>\n<p><strong>TypeError: 'module' object is not callable</strong></p>\n<p>I know I'm doing some mistake or model is bit different, please guide me to the right direction where I can look for solutions.</p>\n<p>Python: 3.7.2\nTensorflow: 2.6.0\nKeras: 2.6.0</p>\n<p><strong>Full Stack Trace</strong></p>\n<pre><code>---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\tensorflow\\python\\ops\\array_ops.py in wrapper(*args, **kwargs)\n    205     try:\n--&gt; 206       return target(*args, **kwargs)\n    207     except (TypeError, ValueError):\n\nTypeError: 'str' object is not callable\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-10-cd6655ece7c5&gt; in &lt;module&gt;\n      7 # loaded_model = tf.keras.models.load_model(&quot;my_custom_model2&quot;)\n      8 \n----&gt; 9 loaded_model = tf.keras.models.load_model('model_notebook.h5')\n     10 # print(loaded_model)\n     11 # print(&quot;------------&quot;)\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\saving\\save.py in load_model(filepath, custom_objects, compile, options)\n    199             (isinstance(filepath, h5py.File) or h5py.is_hdf5(filepath))):\n    200           return hdf5_format.load_model_from_hdf5(filepath, custom_objects,\n--&gt; 201                                                   compile)\n    202 \n    203         filepath = path_to_string(filepath)\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\saving\\hdf5_format.py in load_model_from_hdf5(filepath, custom_objects, compile)\n    179     model_config = json_utils.decode(model_config)\n    180     model = model_config_lib.model_from_config(model_config,\n--&gt; 181                                                custom_objects=custom_objects)\n    182 \n    183     # set weights\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\saving\\model_config.py in model_from_config(config, custom_objects)\n     50                     '`Sequential.from_config(config)`?')\n     51   from keras.layers import deserialize  # pylint: disable=g-import-not-at-top\n---&gt; 52   return deserialize(config, custom_objects=custom_objects)\n     53 \n     54 \n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\layers\\serialization.py in deserialize(config, custom_objects)\n    210       module_objects=LOCAL.ALL_OBJECTS,\n    211       custom_objects=custom_objects,\n--&gt; 212       printable_module_name='layer')\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\utils\\generic_utils.py in deserialize_keras_object(identifier, module_objects, custom_objects, printable_module_name)\n    676             custom_objects=dict(\n    677                 list(_GLOBAL_CUSTOM_OBJECTS.items()) +\n--&gt; 678                 list(custom_objects.items())))\n    679       else:\n    680         with CustomObjectScope(custom_objects):\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\functional.py in from_config(cls, config, custom_objects)\n    661     with generic_utils.SharedObjectLoadingScope():\n    662       input_tensors, output_tensors, created_layers = reconstruct_from_config(\n--&gt; 663           config, custom_objects)\n    664       model = cls(inputs=input_tensors, outputs=output_tensors,\n    665                   name=config.get('name'))\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\functional.py in reconstruct_from_config(config, custom_objects, created_layers)\n   1281       if layer in unprocessed_nodes:\n   1282         for node_data in unprocessed_nodes.pop(layer):\n-&gt; 1283           process_node(layer, node_data)\n   1284 \n   1285   input_tensors = []\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\functional.py in process_node(layer, node_data)\n   1229         input_tensors = (\n   1230             base_layer_utils.unnest_if_single_tensor(input_tensors))\n-&gt; 1231       output_tensors = layer(input_tensors, **kwargs)\n   1232 \n   1233       # Update node index map.\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\base_layer.py in __call__(self, *args, **kwargs)\n    975     if _in_functional_construction_mode(self, inputs, args, kwargs, input_list):\n    976       return self._functional_construction_call(inputs, args, kwargs,\n--&gt; 977                                                 input_list)\n    978 \n    979     # Maintains info about the `Layer.call` stack.\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\base_layer.py in _functional_construction_call(self, inputs, args, kwargs, input_list)\n   1113       # Check input assumptions set after layer building, e.g. input shape.\n   1114       outputs = self._keras_tensor_symbolic_call(\n-&gt; 1115           inputs, input_masks, args, kwargs)\n   1116 \n   1117       if outputs is None:\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\base_layer.py in _keras_tensor_symbolic_call(self, inputs, input_masks, args, kwargs)\n    846       return tf.nest.map_structure(keras_tensor.KerasTensor, output_signature)\n    847     else:\n--&gt; 848       return self._infer_output_signature(inputs, args, kwargs, input_masks)\n    849 \n    850   def _infer_output_signature(self, inputs, args, kwargs, input_masks):\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\engine\\base_layer.py in _infer_output_signature(self, inputs, args, kwargs, input_masks)\n    886           self._maybe_build(inputs)\n    887           inputs = self._maybe_cast_inputs(inputs)\n--&gt; 888           outputs = call_fn(inputs, *args, **kwargs)\n    889 \n    890         self._handle_activity_regularization(inputs, outputs)\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\keras\\layers\\core.py in call(self, inputs, mask, training)\n    901     with tf.GradientTape(watch_accessed_variables=True) as tape,\\\n    902         tf.variable_creator_scope(_variable_creator):\n--&gt; 903       result = self.function(inputs, **kwargs)\n    904     self._check_variables(created_variables, tape.watched_variables())\n    905     return result\n\n~\\AppData\\Roaming\\Python\\Python37\\site-packages\\tensorflow\\python\\ops\\array_ops.py in wrapper(*args, **kwargs)\n    208       # Note: convert_to_eager_tensor currently raises a ValueError, not a\n    209       # TypeError, when given unexpected types.  So we need to catch both.\n--&gt; 210       result = dispatch(wrapper, args, kwargs)\n    211       if result is not OpDispatcher.NOT_SUPPORTED:\n    212         return result\n\nTypeError: 'module' object is not callable\n</code></pre>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 35}]