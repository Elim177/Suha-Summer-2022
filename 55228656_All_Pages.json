[{"items": [{"tags": ["python", "tensorflow", "lstm", "tensorflow-datasets"], "owner": {"account_id": 1720655, "reputation": 820, "user_id": 1757224, "user_type": "registered", "accept_rate": 85, "profile_image": "https://i.stack.imgur.com/yUXOQ.jpg?s=256&g=1", "display_name": "ARAT", "link": "https://stackoverflow.com/users/1757224/arat"}, "is_answered": false, "view_count": 236, "answer_count": 0, "score": 0, "last_activity_date": 1552938740, "creation_date": 1552936908, "last_edit_date": 1552938740, "question_id": 55228656, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/55228656/restoring-a-saved-model-and-evaluating-on-a-new-tensorflow-data-object", "title": "Restoring a saved model and evaluating on a new Tensorflow Data object", "body": "<p>I have this saved model and I want to restore it. After I restore, I want to evaluate it on a new dataset which I feeding with a Tensorflow Data input pipeline. </p>\n\n<pre><code>import tensorflow as tf\nfrom tfwrappers.tf_dataset import Dataset\n\n\ntf.reset_default_graph()\nwith tf.Session() as sess:\n    new_saver = tf.train.import_meta_graph('my_deep_model_2017.ckpt.meta')\n    new_saver.restore(sess, tf.train.latest_checkpoint('./'))\n    print(\"Restored Operations from MetaGraph:\")\n    g = tf.get_default_graph()\n\n    batch_size = 128\n    num_steps = 4\n\n    train_init_op, test_init_op, Xtest, ytest  = Dataset(year = 2017, batch_size = batch_size).build_iterator()\n\n    accuracy_update_op = g.get_tensor_by_name('LSTM/Accuracy/accuracy/update_op:0')\n    accuracy = g.get_tensor_by_name('LSTM/Accuracy/accuracy/value:0')\n\n    auc_update_op = g.get_tensor_by_name('LSTM/AUC/auc/update_op:0')\n    auc = g.get_tensor_by_name('LSTM/AUC/auc/value:0')\n\n    total_test_batch = int((400000/(num_steps * batch_size))+1)\n    tf.global_variables_initializer().run()\n    tf.local_variables_initializer().run()\n    sess.run(test_init_op)\n    for _ in range(total_test_batch):\n        sess.run([auc_update_op, accuracy_update_op])\n    accuracy_test= sess.run(accuracy)\n    AUC_test = sess.run(auc)\n    print(\"Test accuracy: {:&gt;.2%}\".format(accuracy_test), \"Test AUC: {:&gt;.2%}\".format(AUC_test))\n</code></pre>\n\n<p>The error I get is <code>FailedPreconditionError: GetNext() failed because the iterator has not been initialized</code>. However, I already have initialization method <code>sess.run(test_init_op)</code>.</p>\n\n<p><code>Dataset</code> module I have is pretty basic, with a Python generator reading data points from an SQL database and creating a Dataset object.</p>\n\n<pre><code>def build_iterator(self):\n    with tf.name_scope(\"Data\"):\n        train_generator = PairGenerator(sql = '*SQL QUERY 1*'.format(self.year), max_rows=1600400)\n        validation_generator = PairGenerator(sql = '*SQL QUERY 2*'.format(self.year), max_rows=400000)\n        train_dataset = tf.data.Dataset.from_generator(lambda: train_generator, (tf.float32, tf.int32), (tf.TensorShape([self.num_steps, self.num_inputs]), tf.TensorShape([self.num_steps,])))\n        train_dataset=train_dataset.apply(tf.contrib.data.map_and_batch(map_func=lambda *x:(x[0], tf.cast(tf.one_hot(x[1], self.num_classes),tf.int32)), batch_size=self.batch_size, num_parallel_calls=self.num_parallel_calls, drop_remainder=False)).prefetch(self.prefetch_batch_buffer).repeat(self.num_epochs)\n\n        validation_dataset = tf.data.Dataset.from_generator(lambda: validation_generator, (tf.float32, tf.int32), (tf.TensorShape([self.num_steps, self.num_inputs]), tf.TensorShape([self.num_steps,])))\n        validation_dataset=validation_dataset.apply(tf.contrib.data.map_and_batch(map_func=lambda *x:(x[0], tf.cast(tf.one_hot(x[1], self.num_classes),tf.int32)), batch_size=self.batch_size, num_parallel_calls=self.num_parallel_calls, drop_remainder=False)).prefetch(self.prefetch_batch_buffer).repeat(self.num_epochs)\n\n        iterator = tf.data.Iterator.from_structure(train_dataset.output_types, train_dataset.output_shapes)\n        training_init_op = iterator.make_initializer(train_dataset, name='training_init_op')\n        validation_init_op = iterator.make_initializer(validation_dataset, name='validation_init_op')\n\n        X, y = iterator.get_next(name = 'get_next_datapoint')\n    return training_init_op, validation_init_op, X, y\n</code></pre>\n\n<p>Most of the solutions out there is about restoring an iterator and feeding a new dataset. I could not come up with a solution.</p>\n\n<p>EDIT: Forgot to say that this saved model is trained with another tf dataset object. </p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 123}]