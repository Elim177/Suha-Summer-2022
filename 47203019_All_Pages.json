[{"items": [{"tags": ["python", "machine-learning", "tensorflow", "deep-learning"], "owner": {"account_id": 511732, "reputation": 3509, "user_id": 1538049, "user_type": "registered", "accept_rate": 94, "profile_image": "https://i.stack.imgur.com/jp5pz.jpg?s=256&g=1", "display_name": "Ufuk Can Bicici", "link": "https://stackoverflow.com/users/1538049/ufuk-can-bicici"}, "is_answered": true, "view_count": 1303, "accepted_answer_id": 47203632, "answer_count": 1, "score": 3, "last_activity_date": 1510245108, "creation_date": 1510233874, "last_edit_date": 1510245108, "question_id": 47203019, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/47203019/tensorflow-tf-assign-does-not-assign-anything", "title": "Tensorflow: tf.assign does not assign anything", "body": "<p>I am trying to implement a little tweaked version of the Batch Normalization operation; in which I need to keep the moving average values like mean and variance explicitly. In order to do that, I am doing some experimentation with assignment and control dependency mechanisms in the Tensorflow and I run into a mysterious problem. I have the following toy code; in which I am trying to test whether the <code>tf.control_dependencies</code> work as intended:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>dataset = MnistDataSet(validation_sample_count=10000, \nload_validation_from=\"validation_indices\")\nsamples, labels, indices_list, one_hot_labels = \ndataset.get_next_batch(batch_size=GlobalConstants.BATCH_SIZE)\nsamples = np.expand_dims(samples, axis=3)\n\nflat_data = tf.contrib.layers.flatten(GlobalConstants.TRAIN_DATA_TENSOR)\nmean = tf.Variable(name=\"mean\", initial_value=tf.constant(100.0, shape=[784], dtype=tf.float32),\n               trainable=False, dtype=tf.float32)\na = tf.Variable(name=\"a\", initial_value=5.0, trainable=False)\nb = tf.Variable(name=\"b\", initial_value=4.0, trainable=False)\nc = tf.Variable(name=\"c\", initial_value=0.0, trainable=False)\nbatch_mean, batch_var = tf.nn.moments(flat_data, [0])\n\nb_op = tf.assign(b, a)\nmean_op = tf.assign(mean, batch_mean)\nwith tf.control_dependencies([b_op, mean_op]):\n    c = a + b\n\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init)\n\nresults = sess.run([c, mean], feed_dict={GlobalConstants.TRAIN_DATA_TENSOR: samples})\n</code></pre>\n\n<p>I am simply loading a data batch with each entry having 784 dimensions, calculate the moments of it and try to store the <code>batch_mean</code> into the variable <code>mean</code>. I trivially store the variable <code>a</code>'s value into <code>b</code> as well. </p>\n\n<p>In the last line, when I run the graph for the values of <code>c</code> and <code>mean</code>, I see <code>c</code> as 10, which is the expected value. But <code>mean</code> is still a vector of 100's and does not contain the batch mean. It is like the <code>mean_op = tf.assign(mean, batch_mean)</code> has not been executed.</p>\n\n<p>What can be the reason of this? As far as I know, all operations in the <code>tf.control_dependencies</code> call must be executed before any operation in the following context; I explicitly call <code>c</code> here, which is in the context. Am I missing something?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 92}]