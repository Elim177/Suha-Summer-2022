[{"items": [{"tags": ["python", "tensorflow", "keras", "deep-learning", "neural-network"], "owner": {"user_type": "does_not_exist", "display_name": "user12304080"}, "is_answered": true, "view_count": 116, "accepted_answer_id": 64451050, "answer_count": 1, "score": 0, "last_activity_date": 1603230190, "creation_date": 1603178707, "last_edit_date": 1603183706, "question_id": 64440377, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/64440377/no-attribute-compile-how-can-i-modify-the-class-so-that-it-works", "title": "No attribute &#39;compile&#39;, how can I modify the class, so that it works?", "body": "<p>The <code>neuMF</code> class is not a <code>Keras</code>'s class and therefore it doesn't provide any compile method.\nI would better use <code>keras.Model</code> instead of <code>nn.Blocks</code>.</p>\n<p>Unfortunately, I do not really understand what nn.Blocks is and how I could replace it in the class.\nHow should I modfy my code, so that it works with <code>keras.Model</code> and can use the <code>Keras</code> method?</p>\n<p>Here is my code:</p>\n<pre><code>from d2l import mxnet as d2l\nfrom mxnet import autograd, gluon, np, npx\nfrom mxnet.gluon import nn\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom tensorflow.keras import layers\n\n\n    class NeuMF(nn.Block):\n        def init(self, num_factors, num_users, num_items, nums_hiddens,\n                     kwargs):\n            super(NeuMF, self).init(kwargs)\n            self.P = nn.Embedding(num_users, num_factors)\n            self.Q = nn.Embedding(num_items, num_factors)\n            self.U = nn.Embedding(num_users, num_factors)\n            self.V = nn.Embedding(num_items, num_factors)\n            self.mlp = nn.Sequential()\n            for num_hiddens in nums_hiddens:\n                self.mlp.add(nn.Dense(num_hiddens, activation='relu',\n                                      use_bias=True))\n            self.prediction_layer = nn.Dense(1, activation='sigmoid', use_bias=False)\n    \n        def forward(self, user_id, item_id):\n            p_mf = self.P(user_id)\n            q_mf = self.Q(item_id)\n            gmf = p_mf * q_mf\n            p_mlp = self.U(user_id)\n            q_mlp = self.V(item_id)\n            mlp = self.mlp(np.concatenate([p_mlp, q_mlp], axis=1))\n            con_res = np.concatenate([gmf, mlp], axis=1)\n            return self.prediction_layer(con_res)\n    \n    \n    hidden = [5,5,5]\n    \n    model = NeuMF(5, num_users, num_items, hidden)\n    model.compile(\n         #loss=tf.keras.losses.BinaryCrossentropy(),\n        loss=tf.keras.losses.MeanSquaredError(),\n        optimizer=keras.optimizers.Adam(lr=0.001)\n    )\n</code></pre>\n<p>And I get the following error:</p>\n<pre><code>---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n&lt;ipython-input-21-5979072369bd&gt; in &lt;module&gt;()\n      2 \n      3 model = NeuMF(5, num_users, num_items, hidden)\n----&gt; 4 model.compile(\n      5      #loss=tf.keras.losses.BinaryCrossentropy(),\n      6     loss=tf.keras.losses.MeanSquaredError(),\n\nAttributeError: 'NeuMF' object has no attribute 'compile'\n</code></pre>\n<p>Thank you a lot in advance!</p>\n<p>Edit:</p>\n<p>I replaced <code>nn</code> to <code>layers</code></p>\n<pre><code>class NeuMF(keras.Model):\n    def __init__(self, num_factors, num_users, num_items, nums_hiddens,\n                 **kwargs):\n        super(NeuMF, self).__init__(**kwargs)\n        self.P = layers.Embedding(num_users, num_factors)\n        self.Q = layers.Embedding(num_items, num_factors)\n        self.U = layers.Embedding(num_users, num_factors)\n        self.V = layers.Embedding(num_items, num_factors)\n        self.mlp = layers.Sequential()\n        for num_hiddens in nums_hiddens:\n            self.mlp.add(layers.Dense(num_hiddens, activation='relu',\n                                  use_bias=True))\n        self.prediction_layer = layers.Dense(1, activation='sigmoid', use_bias=False)\n\n    def forward(self, user_id, item_id):\n        p_mf = self.P(user_id)\n        q_mf = self.Q(item_id)\n        gmf = p_mf * q_mf\n        p_mlp = self.U(user_id)\n        q_mlp = self.V(item_id)\n        mlp = self.mlp(np.concatenate([p_mlp, q_mlp], axis=1))\n        con_res = np.concatenate([gmf, mlp], axis=1)\n        return self.prediction_layer(con_res)\n</code></pre>\n<p>Then I got an new error:</p>\n<pre><code>---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-26-7e09b0f80300&gt; in &lt;module&gt;()\n      1 hidden = [1,1,1]\n      2 \n----&gt; 3 model = NeuMF(1, num_users, num_items, hidden)\n      4 model.compile(\n      5      #loss=tf.keras.losses.BinaryCrossentropy(),\n\n1 frames\n/usr/local/lib/python3.6/dist-packages/tensorflow/python/keras/layers/embeddings.py in __init__(self, input_dim, output_dim, embeddings_initializer, embeddings_regularizer, activity_regularizer, embeddings_constraint, mask_zero, input_length, **kwargs)\n    102       else:\n    103         kwargs['input_shape'] = (None,)\n--&gt; 104     if input_dim &lt;= 0 or output_dim &lt;= 0:\n    105       raise ValueError('Both `input_dim` and `output_dim` should be positive, '\n    106                        'found input_dim {} and output_dim {}'.format(\n\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n</code></pre>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 267}]