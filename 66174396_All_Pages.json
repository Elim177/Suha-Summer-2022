[{"items": [{"tags": ["python", "tensorflow", "object-detection-api"], "owner": {"account_id": 5745913, "reputation": 1024, "user_id": 4537160, "user_type": "registered", "accept_rate": 33, "profile_image": "https://lh5.googleusercontent.com/-eopRm1RsmD0/AAAAAAAAAAI/AAAAAAAAA7o/ILqdWSiUjTM/photo.jpg?sz=256", "display_name": "Carlo", "link": "https://stackoverflow.com/users/4537160/carlo"}, "is_answered": false, "view_count": 292, "answer_count": 0, "score": 0, "last_activity_date": 1613144080, "creation_date": 1613143142, "last_edit_date": 1613144080, "question_id": 66174396, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/66174396/tensorflow-object-detection-list-index-out-of-range-error-when-rearranging-the", "title": "Tensorflow object detection, list index out of range error when rearranging the code in tutorial", "body": "<p>I was trying the Tensorflow 2 object detection API.</p>\n<p>I ran the code from the tutorial <a href=\"https://tensorflow-object-detection-api-tutorial.readthedocs.io/en/latest/auto_examples/object_detection_camera.html\" rel=\"nofollow noreferrer\">at this link</a>, and everything runs without problems.</p>\n<p>However, I tried to reorganize that code, and now I have something like:</p>\n<pre><code>import os\nimport cv2\nimport numpy as np\nimport tarfile\nimport urllib.request\nimport tensorflow as tf\nfrom object_detection.utils import label_map_util\nfrom object_detection.utils import config_util\nfrom object_detection.utils import visualization_utils as viz_utils\nfrom object_detection.builders import model_builder\n\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'    # Suppress TensorFlow logging\ntf.get_logger().setLevel('ERROR')           # Suppress TensorFlow logging (2)\n# Enable GPU dynamic memory allocation\ngpus = tf.config.experimental.list_physical_devices('GPU')\nfor gpu in gpus:\n    tf.config.experimental.set_memory_growth(gpu, True)\n\ndef main():\n\n    ## create folders\n    data_dir, models_dir = create_data_directories()\n\n    ## --------------------------\n    ## download and extract model\n    ## --------------------------\n    print('Download and extract model')\n    model_date = '20200711'\n    model_name = 'ssd_resnet50_v1_fpn_640x640_coco17_tpu-8'\n    label_filename = 'mscoco_label_map.pbtxt'\n    PATH_TO_CKPT, PATH_TO_CFG, PATH_TO_LABELS = download_models_labels(data_dir, models_dir, model_date, model_name, label_filename)\n\n    ## --------------------------\n    # Load pipeline config and build a detection model\n    ## --------------------------\n    configs = config_util.get_configs_from_pipeline_file(PATH_TO_CFG)\n    model_config = configs['model']\n    detection_model = model_builder.build(model_config=model_config, is_training=False)\n    # Restore checkpoint\n    ckpt = tf.compat.v2.train.Checkpoint(model=detection_model)\n    ckpt.restore(os.path.join(PATH_TO_CKPT, 'ckpt-0')).expect_partial()\n\n\n    ## --------------------------\n    # Load label map data (for plotting)\n    ## --------------------------\n    category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS,\n                                                                        use_display_name=True)\n    ## --------------------------\n    # Define the video stream\n    ## --------------------------\n    cap = cv2.VideoCapture(2)\n\n    while True:\n        # Read frame from camera\n        ret, image_np = cap.read()\n\n        # Expand dimensions since the model expects images to have batch -&gt; shape: [1, None, None, 3]\n        image_np_expanded = np.expand_dims(image_np, axis=0)\n\n\n        detect_fn = get_model_detection_function(detection_model)\n        input_tensor = tf.convert_to_tensor(np.expand_dims(image_np, 0), dtype=tf.float32)\n        detections, predictions_dict, shapes = detect_fn(input_tensor)\n\n        label_id_offset = 1\n        image_np_with_detections = image_np.copy()\n\n        viz_utils.visualize_boxes_and_labels_on_image_array(\n            image_np_with_detections,\n            detections['detection_boxes'][0].numpy(),\n            (detections['detection_classes'][0].numpy() + label_id_offset).astype(int),\n            detections['detection_scores'][0].numpy(),\n            category_index,\n            use_normalized_coordinates=True,\n            max_boxes_to_draw=200,\n            min_score_thresh=.60,\n            agnostic_mode=False)\n\n        # Display output\n        cv2.imshow('object detection', cv2.resize(image_np_with_detections, (800, 600)))\n\n        if cv2.waitKey(25) &amp; 0xFF == ord('q'):\n            break\n\n    cap.release()\n    cv2.destroyAllWindows()\n\ndef create_data_directories():\n    print('Create the data directory')\n    DATA_DIR = os.path.join(os.getcwd(), 'data')\n    MODELS_DIR = os.path.join(DATA_DIR, 'models')\n    for dir in [DATA_DIR, MODELS_DIR]:\n        if not os.path.exists(dir):\n            os.mkdir(dir)\n    return DATA_DIR, MODELS_DIR\n\ndef download_models_labels(DATA_DIR, MODELS_DIR, MODEL_DATE, MODEL_NAME, label_filename):\n    # Download the model\n    # ~~~~~~~~~~~~~~~~~~\n    MODEL_TAR_FILENAME = MODEL_NAME + '.tar.gz'\n    MODELS_DOWNLOAD_BASE = 'http://download.tensorflow.org/models/object_detection/tf2/'\n    MODEL_DOWNLOAD_LINK = MODELS_DOWNLOAD_BASE + MODEL_DATE + '/' + MODEL_TAR_FILENAME\n    PATH_TO_MODEL_TAR = os.path.join(MODELS_DIR, MODEL_TAR_FILENAME)\n    PATH_TO_CKPT = os.path.join(MODELS_DIR, os.path.join(MODEL_NAME, 'checkpoint/'))\n    PATH_TO_CFG = os.path.join(MODELS_DIR, os.path.join(MODEL_NAME, 'pipeline.config'))\n    if not os.path.exists(PATH_TO_CKPT):\n        print('Downloading model. This may take a while... ', end='')\n        urllib.request.urlretrieve(MODEL_DOWNLOAD_LINK, PATH_TO_MODEL_TAR)\n        tar_file = tarfile.open(PATH_TO_MODEL_TAR)\n        tar_file.extractall(MODELS_DIR)\n        tar_file.close()\n        os.remove(PATH_TO_MODEL_TAR)\n        print('Done')\n\n    # Download labels file\n    LABELS_DOWNLOAD_BASE = \\\n        'https://raw.githubusercontent.com/tensorflow/models/master/research/object_detection/data/'\n    PATH_TO_LABELS = os.path.join(MODELS_DIR, os.path.join(MODEL_NAME, label_filename))\n    if not os.path.exists(PATH_TO_LABELS):\n        print('Downloading label file... ', end='')\n        urllib.request.urlretrieve(LABELS_DOWNLOAD_BASE + label_filename, PATH_TO_LABELS)\n        print('Done')\n\n    return PATH_TO_CKPT, PATH_TO_CFG, PATH_TO_LABELS\n\n\n\ndef get_model_detection_function(model):\n##Get a tf.function for detection\n\n    @tf.function\n    def detect_fn(image):\n        &quot;&quot;&quot;Detect objects in image.&quot;&quot;&quot;\n        image, shapes = model.preprocess(image)\n        prediction_dict = model.predict(image, shapes)\n        detections = model.postprocess(prediction_dict, shapes)\n        return detections, prediction_dict, tf.reshape(shapes, [-1])\n    return detect_fn\n\nif __name__ == &quot;__main__&quot;:\n    main()\n\n</code></pre>\n<p>So, I simply rearranged everything to make it (I think!) more readable.\nHowever, after my modifications, I get the error:</p>\n<pre><code> /home/lews/anaconda3/envs/tf/lib/python3.8/site-packages/object_detection/models/ssd_resnet_v1_fpn_keras_feature_extractor.py:204 preprocess  *\n        if resized_inputs.shape.as_list()[3] == 3:\n    IndexError: list index out of range\n</code></pre>\n<p>I found an answer to the same problem <a href=\"https://stackoverflow.com/questions/64589892/tensorflow-2-3-1-indexerror-list-index-out-of-range\">here</a>, and I followed the suggestion of creating a function to return <code>detect_fn</code>, but I'm still getting the error.</p>\n<p>Clearly, I could just stick to the original code in the tutorial, but I'm interested in understanding what's going on with my modification.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 208}]