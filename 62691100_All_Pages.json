[{"items": [{"tags": ["python", "tensorflow", "keras", "tensorflow2.0"], "owner": {"account_id": 438612, "reputation": 22294, "user_id": 826983, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.stack.imgur.com/B9PSD.jpg?s=256&g=1", "display_name": "Stefan Falk", "link": "https://stackoverflow.com/users/826983/stefan-falk"}, "is_answered": false, "view_count": 1220, "answer_count": 2, "score": 3, "last_activity_date": 1616687208, "creation_date": 1593674681, "last_edit_date": 1594491239, "question_id": 62691100, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/62691100/how-to-use-model-input-in-loss-function", "title": "How to use model input in loss function?", "body": "<p>I am trying to use a custom loss-function which depends on some arguments that the model does not have.</p>\n<p>The model has two inputs (<code>mel_specs</code> and <code>pred_inp</code>) and expects a <code>labels</code> tensor for training:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def to_keras_example(example):\n    # Preparing inputs\n    return (mel_specs, pred_inp), labels\n\n# Is a tf.train.Dataset for model.fit(train_data, ...)\ntrain_data = load_dataset(fp, 'train).map(to_keras_example).repeat()\n</code></pre>\n<p>In my loss function I need to calculate the lengths of <code>mel_specs</code> and <code>pred_inp</code>. This means my loss looks like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def rnnt_loss_wrapper(y_true, y_pred, mel_specs_inputs_):\n    input_lengths = get_padded_length(mel_specs_inputs_[:, :, 0])\n    label_lengths = get_padded_length(y_true)\n    return rnnt_loss(\n        acts=y_pred,\n        labels=tf.cast(y_true, dtype=tf.int32),\n        input_lengths=input_lengths,\n        label_lengths=label_lengths\n    )\n</code></pre>\n<p>However, no matter which approach I choose, I am facing some issue.</p>\n<hr />\n<h2>Option 1) Setting the loss-function in model.compile()</h2>\n<p>If I actually wrap the loss function s.t. it returns a function which takes <code>y_true</code>  and <code>y_pred</code> like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def rnnt_loss_wrapper(mel_specs_inputs_):\n    def inner_(y_true, y_pred):\n        input_lengths = get_padded_length(mel_specs_inputs_[:, :, 0])\n        label_lengths = get_padded_length(y_true)\n        return rnnt_loss(\n            acts=y_pred,\n            labels=tf.cast(y_true, dtype=tf.int32),\n            input_lengths=input_lengths,\n            label_lengths=label_lengths\n        )\n    return inner_\n\nmodel = create_model(hparams)\nmodel.compile(\n    optimizer=optimizer,\n    loss=rnnt_loss_wrapper(model.inputs[0]\n)\n</code></pre>\n<p>Here I get a <code>_SymbolicException</code> after calling <code>model.fit()</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>tensorflow.python.eager.core._SymbolicException: Inputs to eager execution function cannot be Keras symbolic tensors, but found [...]\n</code></pre>\n<hr />\n<h2>Option 2) Using model.add_loss()</h2>\n<p>The documentation of <a href=\"https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer#add_loss\" rel=\"nofollow noreferrer\"><code>add_loss()</code></a> states:</p>\n<blockquote>\n<pre class=\"lang-none prettyprint-override\"><code>[Adds a..] loss tensor(s), potentially dependent on layer inputs.\n..\nArguments:\n  losses: Loss tensor, or list/tuple of tensors. Rather than tensors, losses\n    may also be zero-argument callables which create a loss tensor.\n  inputs: Ignored when executing eagerly. If anything ...\n</code></pre>\n</blockquote>\n<p>So I tried to do the following:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def rnnt_loss_wrapper(y_true, y_pred, mel_specs_inputs_):\n    input_lengths = get_padded_length(mel_specs_inputs_[:, :, 0])\n    label_lengths = get_padded_length(y_true)\n    return rnnt_loss(\n        acts=y_pred,\n        labels=tf.cast(y_true, dtype=tf.int32),\n        input_lengths=input_lengths,\n        label_lengths=label_lengths\n    )\n\nmodel = create_model(hparams)\nmodel.add_loss(\n    rnnt_loss_wrapper(\n        y_true=model.inputs[2],\n        y_pred=model.outputs[0],\n        mel_specs_inputs_=model.inputs[0],\n    ),\n    inputs=True\n)\nmodel.compile(\n    optimizer=optimizer\n)\n</code></pre>\n<p>However, calling <code>model.fit()</code> throws a <code>ValueError</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>ValueError: No gradients provided for any variable: [...]\n</code></pre>\n<hr />\n<p>Is any of the above options supposed to work?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 279}]