[{"items": [{"tags": ["python", "machine-learning", "tensorflow", "neural-network"], "owner": {"user_type": "does_not_exist", "display_name": "user9068026"}, "is_answered": false, "view_count": 296, "answer_count": 0, "score": 1, "last_activity_date": 1549971466, "creation_date": 1512659547, "last_edit_date": 1512662193, "question_id": 47698121, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/47698121/tensorflow-cnn-model-perform-good-in-train-set-but-poor-in-validation-set", "title": "Tensorflow CNN model perform good in train set, but poor in validation set", "body": "<p>I have build a cnn model (regression) using tensorflow. But it performs good in train set but poor in validation/test set.  Below is the curve of loss, the red line is loss of train set, and the blue line is for validation set:</p>\n\n<p><img src=\"https://i.stack.imgur.com/2cEmy.jpg\" alt=\"image\"></p>\n\n<p>Is this overfitting? I try to use regularzation and dropout in it, the the result is not changed.</p>\n\n<p>This is my model and loss function:</p>\n\n<pre><code>def weight_variable(shape, reg = False):\n    initial = tf.truncated_normal(shape, stddev=0.1)\n    #initial = tf.random_uniform(shape)\n    w = tf.Variable(initial)\n    if reg:\n        tf.add_to_collection('reg', w)\n    return w\n\ndef bias_variable(shape):\n    initial = tf.constant(0.1, shape=shape)\n    return tf.Variable(initial)\n\ndef conv2d(x, W, stride):\n    return tf.nn.conv2d(x, W, strides=[1, stride, stride, 1], padding='VALID')\n\ndef cnn_steer():\n\n    with tf.name_scope('input'):\n        x = tf.placeholder(tf.float32, shape=[None, 66, 200, 3])\n        y_ = tf.placeholder(tf.float32, shape=[None])\n\n    with tf.name_scope('keep_prob'):\n        keep_prob = tf.placeholder(tf.float32)\n\n    x_image = x\n\n    with tf.name_scope('conv1'):\n        # first convolutional layer\n        W_conv1 = weight_variable([5, 5, 3, 24])\n        b_conv1 = bias_variable([24])\n\n        h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1, 2) + b_conv1)\n\n\n    with tf.name_scope('conv2'):\n        # second convolutional layer\n        W_conv2 = weight_variable([5, 5, 24, 36])\n        b_conv2 = bias_variable([36])\n\n        h_conv2 = tf.nn.relu(conv2d(h_conv1, W_conv2, 2) + b_conv2)\n\n\n    with tf.name_scope('conv3'):\n        # third convolutional layer\n        W_conv3 = weight_variable([5, 5, 36, 48])\n        b_conv3 = bias_variable([48])\n\n        h_conv3 = tf.nn.relu(conv2d(h_conv2, W_conv3, 2) + b_conv3)\n\n\n    with tf.name_scope('conv4'):\n        # fourth convolutional layer\n        W_conv4 = weight_variable([3, 3, 48, 64])\n        b_conv4 = bias_variable([64])\n\n        h_conv4 = tf.nn.relu(conv2d(h_conv3, W_conv4, 1) + b_conv4)\n\n\n    with tf.name_scope('conv5'):\n        # fifth convolutional layer\n        W_conv5 = weight_variable([3, 3, 64, 64])\n        b_conv5 = bias_variable([64])\n\n        h_conv5 = tf.nn.relu(conv2d(h_conv4, W_conv5, 1) + b_conv5)\n\n    with tf.name_scope('fc1'):\n        # fully connected layer 1\n        W_fc1 = weight_variable([1152, 1164], True)\n        b_fc1 = bias_variable([1164])\n\n        h_conv5_flat = tf.reshape(h_conv5, [-1, 1152])\n        h_fc1 = tf.nn.relu(tf.matmul(h_conv5_flat, W_fc1) + b_fc1)\n\n        h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n\n    with tf.name_scope('fc2'):\n        # fully connected layer 2\n        W_fc2 = weight_variable([1164, 100], True)\n        b_fc2 = bias_variable([100])\n\n        h_fc2 = tf.nn.relu(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)\n\n        h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob)\n\n    with tf.name_scope('fc3'):\n        # fully connected layer 3\n        W_fc3 = weight_variable([100, 50], True)\n        b_fc3 = bias_variable([50])\n\n        h_fc3 = tf.nn.relu(tf.matmul(h_fc2_drop, W_fc3) + b_fc3)\n\n        h_fc3_drop = tf.nn.dropout(h_fc3, keep_prob)\n\n    with tf.name_scope('fc4'):\n        # fully connected layer 4\n        W_fc4 = weight_variable([50, 10], True)\n        b_fc4 = bias_variable([10])\n\n        h_fc4 = tf.nn.relu(tf.matmul(h_fc3_drop, W_fc4) + b_fc4)\n\n        h_fc4_drop = tf.nn.dropout(h_fc4, keep_prob)\n\n    with tf.name_scope('output'):\n        # output\n        W_fc5 = weight_variable([10, 1])\n        b_fc5 = bias_variable([1])\n\n\n        # y = tf.multiply(tf.atan(tf.matmul(h_fc4_drop, W_fc5) + b_fc5), 2)\n        y = tf.matmul(h_fc4_drop, W_fc5) + b_fc5\n\n    return x, y_, y, keep_prob\n</code></pre>\n\n<p>And the loss function is:</p>\n\n<pre><code>regularizer = tf.contrib.layers.l2_regularizer(scale = 0.02)\nreg_var = tf.get_collection('reg')\nreg_term = tf.contrib.layers.apply_regularization(regularizer, reg_var)\nloss = tf.reduce_mean(tf.square(y_actual - tf.transpose(y_predict)))\nr_loss = loss + reg_term\n</code></pre>\n\n<p>The keep_prob I used is 0.6</p>\n\n<p>Can someone tell me what's wrong with my model?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 91}]