[{"items": [{"tags": ["tensorflow", "tensorflow2.0"], "owner": {"account_id": 13748449, "reputation": 71, "user_id": 9921328, "user_type": "registered", "profile_image": "https://lh3.googleusercontent.com/-O_eDlo1gEWk/AAAAAAAAAAI/AAAAAAAAAAA/AB6qoq3Yz6JA0TtnfDnISfS-AsIRf6xXLg/mo/photo.jpg?sz=256", "display_name": "Junhyeok Ahn", "link": "https://stackoverflow.com/users/9921328/junhyeok-ahn"}, "is_answered": true, "view_count": 67, "answer_count": 1, "score": 0, "last_activity_date": 1588273892, "creation_date": 1588267112, "question_id": 61529148, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/61529148/using-autograph-when-calculating-gradient-over-tf-case", "title": "Using autograph when calculating gradient over tf.case", "body": "<p>I am trying to compute a gradient over tf.case using an autograph.</p>\n\n<p>For example, let's say I have a case function where it takes a batch of input and computes output based on the sign of the input:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def case_fn(x):                                                                                                                                                                                                                                                                                                          \n    N = tf.shape(x)[0]                                                                                                                                                                                                                                                                                                   \n    positive_idx = tf.cast(tf.squeeze(tf.where(tf.squeeze(tf.math.greater(x, 0.)))),tf.int32)                                                                                                                                                                                                                            \n    negative_idx = tf.cast(tf.squeeze(tf.where(tf.squeeze(tf.math.less_equal(x, 0.)))),tf.int32)                                                                                                                                                                                                                         \n    def all_positive_case():                                                                                                                                                                                                                                                                                             \n        y_positive = x*2.                                                                                                                                                                                                                                                                                                \n\n        return y_positive                                                                                                                                                                                                                                                                                                \n\n    def all_negative_case():                                                                                                                                                                                                                                                                                             \n        y_negative = x-2.                                                                                                                                                                                                                                                                                                \n\n        return y_negative                                                                                                                                                                                                                                                                                                \n\n    def some_positive_some_negative_case():                                                                                                                                                                                                                                                                              \n        x_positive = tf.gather(x, positive_idx)                                                                                                                                                                                                                                                                          \n        x_negative = tf.gather(x, negative_idx)                                                                                                                                                                                                                                                                          \n\n        y_positive = x_positive*2.                                                                                                                                                                                                                                                                                       \n        y_negative = x_negative-2.                                                                                                                                                                                                                                                                                       \n\n        y_positive = tf.scatter_nd(tf.expand_dims(positive_idx,1),y_positive,tf.stack([N,1]))                                                                                                                                                                                                                            \n        y_negative = tf.scatter_nd(tf.expand_dims(negative_idx,1),y_negative,tf.stack([N,1]))                                                                                                                                                                                                                            \n\n        return y_positive + y_negative                                                                                                                                                                                                                                                                                   \n\n    all_positive = tf.math.equal(tf.shape(negative_idx)[0], 0)                                                                                                                                                                                                                                                           \n    all_negative = tf.math.equal(tf.shape(positive_idx)[0], 0)                                                                                                                                                                                                                                                           \n    return tf.case([(all_positive, all_positive_case), (all_negative, all_negative_case)], default=some_positive_some_negative_case)\n</code></pre>\n\n<p>Then, I calculate a gradient with the following code:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>trainable_variable = tf.Variable([[1.], [-1.], [2.], [-2.]])                                                                                                                                                                                                                                                             \n@tf.function                                                                                                                                                                                                                                                                                                             \ndef compute_grad():                                                                                                                                                                                                                                                                                                      \n    with tf.GradientTape() as tape:                                                                                                                                                                                                                                                                                      \n        y = case_fn(trainable_variable)                                                                                                                                                                                                                                                                                  \n    grad = tape.gradient(y, trainable_variable)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n    return grad                                                                                                                                                                                                                                                                                                          \n\nprint(compute_grad())   \n</code></pre>\n\n<p>If I do not use <code>@tf.function</code> decorator, it returns a correct value which is <code>IndexedSlices(indices=tf.Tensor([0, 2, 1, 3], shape=(4,), dtype=int32), values=tf.Tensor([[2.],[2.],[1.],[1.]], shape=(4, 1), dtype=float32), dense_shape=tf.Tensor([4 1], shape=(2,), dtype=int32))</code>.\nHowever, if I use <code>@tf.function</code> decorator, it returns a value error saying</p>\n\n<pre><code>Traceback (most recent call last):\n  File \"examples/case_gradient.py\", line 102, in &lt;module&gt;\n    print(compute_grad())\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/def_function.py\", line 568, in __call__\n    result = self._call(*args, **kwds)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/def_function.py\", line 615, in _call\n    self._initialize(args, kwds, add_initializers_to=initializers)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/def_function.py\", line 497, in _initialize\n    *args, **kwds))\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/function.py\", line 2389, in _get_concrete_function_internal_garbage_collected\n    graph_function, _, _ = self._maybe_define_function(args, kwargs)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/function.py\", line 2703, in _maybe_define_function\n    graph_function = self._create_graph_function(args, kwargs)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/function.py\", line 2593, in _create_graph_function\n    capture_by_value=self._capture_by_value),\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/framework/func_graph.py\", line 978, in func_graph_from_py_func\n    func_outputs = python_func(*func_args, **func_kwargs)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/def_function.py\", line 439, in wrapped_fn\n    return weak_wrapped_fn().__wrapped__(*args, **kwds)\n  File \"/home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/framework/func_graph.py\", line 968, in wrapper\n    raise e.ag_error_metadata.to_exception(e)\nValueError: in converted code:\n\n    examples/case_gradient.py:99 compute_grad  *\n        grad = tape.gradient(y, trainable_variable)\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/backprop.py:1029 gradient\n        unconnected_gradients=unconnected_gradients)\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/imperative_grad.py:77 imperative_grad\n        compat.as_str(unconnected_gradients.value))\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/eager/backprop.py:141 _gradient_function\n        return grad_fn(mock_op, *out_grads)\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:121 _IfGrad\n        false_graph, grads, util.unique_grad_fn_name(false_graph.name))\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:381 _create_grad_func\n        func_graph=_CondGradFuncGraph(name, func_graph))\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/framework/func_graph.py:978 func_graph_from_py_func\n        func_outputs = python_func(*func_args, **func_kwargs)\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:380 &lt;lambda&gt;\n        lambda: _grad_fn(func_graph, grads), [], {},\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:371 _grad_fn\n        src_graph=func_graph)\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/gradients_util.py:669 _GradientsHelper\n        lambda: grad_fn(op, *out_grads))\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/gradients_util.py:336 _MaybeCompile\n        return grad_fn()  # Exit early\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/gradients_util.py:669 &lt;lambda&gt;\n        lambda: grad_fn(op, *out_grads))\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:183 _IfGrad\n        building_gradient=True,\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:219 _build_cond\n        _make_indexed_slices_indices_types_match(_COND, [true_graph, false_graph])\n    /home/junhyeok/.venv/ccmbrl/lib/python3.6/site-packages/tensorflow_core/python/ops/cond_v2.py:652 _make_indexed_slices_indices_types_match\n        (current_index, len(branch_graphs[0].outputs)))\n\n    ValueError: Insufficient elements in branch_graphs[0].outputs.\n    Expected: 6\n    Actual: 3\n</code></pre>\n\n<p>What am I missing here?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 138}]