[{"items": [{"tags": ["python-3.x", "conv-neural-network", "tensorflow2.0", "vgg-net"], "owner": {"account_id": 4441934, "reputation": 1952, "user_id": 3616293, "user_type": "registered", "accept_rate": 35, "profile_image": "https://www.gravatar.com/avatar/cf7556b4227065cec9496375d64fea3d?s=256&d=identicon&r=PG&f=1", "display_name": "Arun", "link": "https://stackoverflow.com/users/3616293/arun"}, "is_answered": true, "view_count": 619, "answer_count": 1, "score": 0, "last_activity_date": 1588516595, "creation_date": 1586675093, "last_edit_date": 1588516595, "question_id": 61167942, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/61167942/vgg-19-tensorflow-2-0-implementation", "title": "VGG-19 Tensorflow 2.0 implementation", "body": "<p>I am trying to implement VGG-19 CNN on CIFAR-10 dataset where the images are of dimension (32, 32, 3). The training set has 50000 images while the testing set has 10000 images. \nI am using Python 3.7 and TensorFlow 2.0. I have preprocessed the dataset by normalizing them-</p>\n\n<pre><code># Normalize the training and testing datasets-\nX_train /= 255.0\nX_test /= 255.0\n</code></pre>\n\n<p>I have then designed a CNN-</p>\n\n<pre><code>def vgg_19():\n\n    \"\"\"\n    Function to define the architecture of a convolutional neural network\n    model following VGG-19 architecture for CIFAR-10 dataset.\n\n    Vgg-19 architecture-\n    64, 64, pool                 -- convolutional layers\n    128, 128, pool               -- convolutional layers\n    256, 256, 256, 256, max-pool -- convolutional layers\n    512, 512, 512, 512, max-pool -- convolutional layers\n    512, 512, 512, 512, avg-pool -- convolutional layers\n    256, 256, 10                 -- fully connected layers\n\n    Output: Returns designed and compiled convolutional neural network model\n    \"\"\"\n\n\n    l = tf.keras.layers\n\n    model = Sequential()\n\n    model.add(\n    Conv2D(\n            filters = 64, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same',\n            input_shape=(32, 32, 3)\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 64, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    MaxPooling2D(\n            pool_size = (2, 2),\n            strides = (2, 2)\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 128, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 128, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    MaxPooling2D(\n            pool_size = (2, 2),\n            strides = (2, 2)\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 256, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 256, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 256, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 256, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    MaxPooling2D(\n            pool_size = (2, 2),\n            strides = (2, 2)\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    MaxPooling2D(\n            pool_size = (2, 2),\n            strides = (2, 2)\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n    model.add(\n    Conv2D(\n            filters = 512, kernel_size = (3, 3),\n            activation='relu', kernel_initializer = tf.initializers.GlorotUniform(),\n            strides = (1, 1), padding = 'same'\n        )\n    )\n\n\n    model.add(\n    AveragePooling2D(\n        pool_size=(2, 2), strides=(2, 2)\n    )\n    )\n\n\n    '''\n    model.add(\n        MaxPooling2D(\n            pool_size = (2, 2),\n            strides = (2, 2)\n        )\n    )\n    '''\n\n    model.add(Flatten())\n\n\n    model.add(\n    Dense(\n            units = 256, activation='relu'\n        )\n    )\n\n    model.add(\n    Dense(\n            units = 256, activation='relu'\n        )\n    )\n\n    '''\n    model.add(\n    Dense(\n            units = 1000, activation='relu'\n        )\n    )\n    '''\n\n    model.add(\n    Dense(\n            units = 10, activation='softmax'\n        )\n    )\n\n\n    # Compile pruned CNN-\n    model.compile(\n        loss=tf.keras.losses.categorical_crossentropy,\n        # optimizer='adam',\n        optimizer = tf.keras.optimizers.SGD(learning_rate=0.01, momentum=0.9),\n        metrics=['accuracy']\n    )\n\n    return model\n</code></pre>\n\n<p>However, when I try to train it-</p>\n\n<pre><code>history = orig_model.fit(\n        x = X_train, y = y_train,\n        batch_size = batch_size,\n        epochs = num_epochs,\n        verbose = 1,\n        # callbacks = callback,\n        validation_data = (X_test, y_test),\n        shuffle = True\n    )\n</code></pre>\n\n<p>The designed CNN gives a validation accuracy of about 9%.</p>\n\n<p>What's going wrong?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 239}]