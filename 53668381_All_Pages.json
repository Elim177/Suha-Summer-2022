[{"items": [{"tags": ["python", "tensorflow", "deep-learning"], "owner": {"account_id": 511732, "reputation": 3509, "user_id": 1538049, "user_type": "registered", "accept_rate": 94, "profile_image": "https://i.stack.imgur.com/jp5pz.jpg?s=256&g=1", "display_name": "Ufuk Can Bicici", "link": "https://stackoverflow.com/users/1538049/ufuk-can-bicici"}, "is_answered": false, "view_count": 348, "answer_count": 0, "score": 1, "last_activity_date": 1544181155, "creation_date": 1544181155, "question_id": 53668381, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/53668381/tensorflow-tf-control-dependencies-does-not-work-as-expected", "title": "Tensorflow: tf.control_dependencies does not work as expected", "body": "<p>I want to accomplish the following: I have a (A,B,C,D) shaped tensor, say, (110,14,14,32). In the computation graph, I want to obtain the shape of this tensor as another tensor and want to set the first dimension to a another value, say 250. (250 will come from a <code>tf.placeholder</code>). Then I will use this in a <code>tf.scatter_nd</code> call. To test this, I have implemented the following:</p>\n\n<pre><code>batch_size = 250\nsparse_length = 110\nsparse_arr = np.random.uniform(low=-1.0, high=1.0, size=(sparse_length, 14, 14, 32))\nindices = np.array(sorted(np.random.choice(a=batch_size, size=sparse_length, replace=False).tolist()))\n\nsparse_tensor = tf.placeholder(name=\"sparse_arr\", dtype=tf.float32)\nbatch_size_tensor = tf.placeholder(name=\"batch_size\", dtype=tf.int32)\nshape_tensor = tf.Variable(name=\"shape\", trainable=False, initial_value=[0] * 4)\nshape_assign_op = tf.assign(shape_tensor, tf.shape(sparse_tensor))\nset_batch_size_op = tf.assign(shape_tensor[0], batch_size_tensor)\n\nsess = tf.Session()\ninit = tf.global_variables_initializer()\nsess.run(init)\n\nwith tf.control_dependencies([shape_assign_op]):\n   with tf.control_dependencies([set_batch_size_op]):\n       x = tf.identity(shape_tensor)\n\nresult = sess.run([x], feed_dict={sparse_tensor: sparse_arr, batch_size_tensor: batch_size})\n</code></pre>\n\n<p>In the code above, <code>result</code> returns with <code>(110,14,14,32)</code>. It acts like the second <code>tf.assign</code> operation in the inner <code>tf.control_dependencies</code> block is not executed. What I am doing is first getting the shape of the input tensor with <code>tf.shape</code> and assigning it into a variable, <code>shape_tensor</code>. Then in the second <code>tf.assign</code>, I want to set the first dimension of <code>shape_tensor</code> to an another value. (Since Tensorflow supports sliced indexing only for <code>tf.Variable</code> I declare <code>shape_tensor</code>as such). In the actual program, the real operations involing <code>tf.scatter_nd</code> will follow in the <code>tf.control_dependencies</code> block, I am just mocking it with an identity transform in this case. In order the following operations to execute correctly, I need to obtain the shape of incoming tensor into another tensor and set its first dimension to another value, in that certain order and therefore I am using the <code>tf.control_dependencies</code> s. But it does not work as expected. Are cascaded <code>tf.control_dependencies</code>  not supported? What am I doing wrong here? Or is there any easier way to implement this behavior?</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 63}]