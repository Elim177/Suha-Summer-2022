[{"items": [{"tags": ["javascript", "artificial-intelligence"], "owner": {"user_type": "does_not_exist", "display_name": "user9526105"}, "is_answered": false, "view_count": 31, "answer_count": 0, "score": 1, "last_activity_date": 1568673360, "creation_date": 1568605752, "last_edit_date": 1568673360, "question_id": 57950137, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/57950137/how-to-fix-similar-predictions-in-tenserflow-js", "title": "How to fix similar predictions in tenserflow.js", "body": "<p>I'm doing a coding challenge from the coding train, and I'm trying to improve on his code. The idea is that the cars are driving around a race track. When I went back to check something, I noticed that I misspelled \"activation: sigmoid\", as in activation function. When I fixed it, the cars seemed to be driving in circles.</p>\n\n<p>I'm a very new coder (as I am 12 years old), so many things in my code are broken, hard to understand, or just not finished. I'm also pretty new to stack overflow, so I might be breaking a lot of rules.</p>\n\n<p>The link to download my project is here: <a href=\"https://1drv.ms/u/s!ApmY_SAko19ChzCKe5uNT7I9EZAX?e=YUg2ff\" rel=\"nofollow noreferrer\">https://1drv.ms/u/s!ApmY_SAko19ChzCKe5uNT7I9EZAX?e=YUg2ff</a></p>\n\n<p>The misspelled words are at lines 29 and 34 in the nn.js file.</p>\n\n<p>car.js</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function pldistance(p1, p2, x, y) {\r\n  const num = abs((p2.y - p1.y) * x - (p2.x - p1.x) * y + p2.x * p1.y - p2.y * p1.x);\r\n  const den = p5.Vector.dist(p1, p2);\r\n  return num / den;\r\n}\r\n\r\nclass Car {\r\n  constructor(brain, color = [random(255), random(255), random(255)]) {\r\n    this.colorGene = color;\r\n    this.dead = false;\r\n    this.finished = false;\r\n    this.fitness = 0;\r\n    this.rays = [];\r\n    this.wallRays = [];\r\n    this.degreeOfSight = degreeOfSight;\r\n    this.degreeOfRays = degreeOfSight / (numOfRays - 1);\r\n    if (this.degreeOfSight == 360) {\r\n      this.degreeOfRays = degreeOfSight / numOfRays;\r\n    }\r\n    this.pos = createVector(start.x, start.y);\r\n    this.vel = createVector();\r\n    this.acc = createVector();\r\n    this.sight = sight;\r\n    this.maxspeed = maxspeed;\r\n    this.maxforce = maxTurningSpeed;\r\n    this.currentGoal = 0;\r\n    this.timeTillDeadC = timeTillDead;\r\n    this.timeTillDead = this.timeTillDeadC;\r\n    this.goal;\r\n    this.rate = mutationRate;\r\n    if (degreeOfSight != 360) {\r\n      for (let a = -(this.degreeOfSight / 2); a &lt;= this.degreeOfSight / 2; a += this.degreeOfRays) {\r\n        this.rays.push(new Ray(this.pos, radians(a)));\r\n      }\r\n    } else {\r\n      for (let a = -(this.degreeOfSight / 2); a &lt; this.degreeOfSight / 2; a += this.degreeOfRays) {\r\n        this.rays.push(new Ray(this.pos, radians(a)));\r\n      }\r\n    }\r\n\r\n    for (let a = 0; a &lt; 360; a += 45) {\r\n      this.wallRays.push(new Ray(this.pos, radians(a)));\r\n    }\r\n    if (brain) {\r\n      this.brain = brain.copy();\r\n    } else {\r\n      this.brain = new NeuralNetwork(this.rays.length + 2, 16, 2);\r\n    }\r\n  }\r\n\r\n  applyForce(force) {\r\n    this.acc.add(force);\r\n  }\r\n\r\n  update(x, y) {\r\n    this.timeTillDead--;\r\n\r\n    if (this.timeTillDead &lt;= 0) {\r\n      this.dead = true;\r\n    }\r\n\r\n    if (!this.dead || this.finished) {\r\n      this.pos.add(this.vel);\r\n      this.vel.add(this.acc);\r\n      this.vel.limit(this.maxspeed);\r\n      this.acc.set(0, 0);\r\n    }\r\n\r\n    for (let i = 0; i &lt; this.rays.length; i++) {\r\n      this.rays[i].rotate(this.vel.heading());\r\n    }\r\n    for (let i = 0; i &lt; this.wallRays.length; i++) {\r\n      this.wallRays[i].rotate(this.vel.heading());\r\n    }\r\n  }\r\n\r\n  show(walls) {\r\n    push();\r\n    translate(this.pos.x, this.pos.y);\r\n    if (visualization) {\r\n      fill(this.colorGene[0], this.colorGene[1], this.colorGene[1]);\r\n    } else {\r\n      fill(0);\r\n    }\r\n    stroke(255);\r\n    const heading = this.vel.heading();\r\n    rotate(heading);\r\n    rectMode(CENTER);\r\n    rect(0, 0, 10, 5);\r\n    pop();\r\n    if (!this.dead) {\r\n      checkpoints[this.currentGoal].show();\r\n    }\r\n\r\n    for (let i = 0; i &lt; this.rays.length; i++) {\r\n      let closest = null;\r\n      let record = this.sight;\r\n      for (let wall of walls) {\r\n        const pt = this.rays[i].cast(wall);\r\n        if (pt) {\r\n          const d = p5.Vector.dist(this.pos, pt);\r\n          if (d &lt; record &amp;&amp; d &lt; this.sight) {\r\n            record = d;\r\n            closest = pt;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (closest) {\r\n        if (showLines) {\r\n          ellipse(closest.x, closest.y, 4)\r\n          stroke(255, 100)\r\n          line(this.pos.x, this.pos.y, closest.x, closest.y);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  check(checkpoints, walls) {\r\n    if (!this.dead) {\r\n      this.goal = checkpoints[this.currentGoal];\r\n      const d = pldistance(this.goal.a, this.goal.b, this.pos.x, this.pos.y);\r\n      if (d &lt; 5) {\r\n        this.fitness++;\r\n        this.currentGoal++;\r\n        this.timeTillDead = this.timeTillDeadC;\r\n        if (this.currentGoal == checkpoints.length) {\r\n          this.finished = true;\r\n          this.fitness = this.fitness * 1.5;\r\n\r\n          if (endBarrier) {\r\n            this.dead = true;\r\n          } else {\r\n            this.currentGoal = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i &lt; this.wallRays.length; i++) {\r\n      let closest = null;\r\n      let record = this.sight;\r\n      for (let wall of walls) {\r\n        const pt = this.wallRays[i].cast(wall);\r\n        if (pt) {\r\n          const d = p5.Vector.dist(this.pos, pt);\r\n          if (d &lt; record) {\r\n            record = d;\r\n            closest = pt;\r\n          }\r\n        }\r\n      }\r\n      if (record &lt; 4) {\r\n        this.dead = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  look(walls) {\r\n    const inputs = [];\r\n    for (let i = 0; i &lt; this.wallRays.length; i++) {\r\n      let closest = null;\r\n      let record = this.sight;\r\n      for (let wall of walls) {\r\n        const pt = this.rays[i].cast(wall);\r\n        if (pt) {\r\n          const d = p5.Vector.dist(this.pos, pt);\r\n          if (d &lt; record &amp;&amp; d &lt; this.sight) {\r\n            record = d;\r\n            closest = pt;\r\n          }\r\n        }\r\n      }\r\n      inputs[i] = map(record, 0, 50, 1, 0);\r\n    }\r\n    inputs.push(end.x);\r\n    inputs.push(end.y);\r\n    const output = this.brain.predict(inputs);\r\n    let angle = map(output[0], 0, 1, -PI, PI);\r\n    let speed = map(output[1], 0, 1, -this.maxspeed, this.maxspeed);\r\n    angle += this.vel.heading();\r\n    const steering = p5.Vector.fromAngle(angle);\r\n    steering.setMag(speed);\r\n    steering.limit(this.maxforce);\r\n    this.applyForce(steering);\r\n  }\r\n\r\n  mutateDemBabies() {\r\n    if (this.finished) {\r\n      this.rate = finishingMutationRate;\r\n    }\r\n    this.brain.mutate(this.rate);\r\n    let changeColor = this.brain.mutated();\r\n\r\n    if (changeColor) {\r\n      for (let color of this.colorGene) {\r\n        let r = map(random(20), 0, 20, -25, 25);\r\n        color += r;\r\n      }\r\n    }\r\n\r\n    this.rate = mutationRate;\r\n  }\r\n\r\n  dispose() {\r\n    this.brain.dispose();\r\n  }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>nn.js</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//&lt;script src=\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.1.0/dist/tf.min.js\"&gt;&lt;/script&gt;\r\nclass NeuralNetwork {\r\n  //this how many inputs, hidden, and output nodes there are. modelC is the brain that we want to copy to give to the new bird\r\n  constructor(inputNumber, hiddenNumber, outputNumber, modelC) {\r\n    if (modelC instanceof tf.Sequential) {\r\n      //this is the making a copy of the neural network\r\n      this.input_nodes = inputNumber;\r\n      this.hidden_nodes = hiddenNumber;\r\n      this.output_nodes = outputNumber;\r\n      this.model = modelC;\r\n    } else {\r\n      //this is the creating a random brain\r\n      this.input_nodes = inputNumber;\r\n      this.hidden_nodes = hiddenNumber;\r\n      this.output_nodes = outputNumber;\r\n      this.model = this.createBrain();\r\n    }\r\n\r\n    this.changeColor = false;\r\n  }\r\n\r\n  createBrain() {\r\n    //the model is the neural network\r\n    const model = tf.sequential();\r\n    //configuring the hidden layer\r\n    const hiddenLayer = tf.layers.dense({\r\n      units: this.hidden_nodes,\r\n      inputShape: [this.input_nodes],\r\n      activaation: \"sigmoid\"\r\n    });\r\n    //configuring the output layer\r\n    const outputLayer = tf.layers.dense({\r\n      units: this.output_nodes,\r\n      activaation: \"sigmoid\"\r\n    });\r\n    //adding the hidden layer to the model\r\n    model.add(hiddenLayer);\r\n    //adding the output layer to the model\r\n    model.add(outputLayer);\r\n    //returning the model\r\n    return model;\r\n  }\r\n\r\n  predict(inputs) {\r\n    //clearing the tensors after using them\r\n    //then returning the output\r\n    return tf.tidy(() =&gt; {\r\n      //creating a tensor with the inputs\r\n      const xs = tf.tensor2d([inputs]);\r\n      //running the inputs through the neural network\r\n      const ys = this.model.predict(xs);\r\n      //getting the raw numbers from the tensor object\r\n      const outputs = ys.dataSync();\r\n      //returning the outputs\r\n      return outputs;\r\n    });\r\n  }\r\n\r\n  copy() {\r\n    //clearing the tensors after using them\r\n    //then returning the output\r\n    return tf.tidy(() =&gt; {\r\n      //creating a new neural network\r\n      const modelCopy = this.createBrain();\r\n      //getting the weights from the old neural network\r\n      const weights = this.model.getWeights();\r\n      //setting the new weights\r\n      modelCopy.setWeights(weights);\r\n      //making a new network but this time with all the weights then returning it\r\n      return new NeuralNetwork(\r\n        this.input_nodes,\r\n        this.hidden_nodes,\r\n        this.output_nodes,\r\n        modelCopy\r\n      );\r\n    });\r\n  }\r\n\r\n  mutate(rate, colorGene) {\r\n    //clearing the tensors after using them\r\n    tf.tidy(() =&gt; {\r\n      this.changeColor = false;\r\n      //getting the weights so that we can change them later\r\n      const weights = this.model.getWeights();\r\n      //the variable that will be holding the mutated weights\r\n      const mutatedWeights = [];\r\n      for (let i = 0; i &lt; weights.length; i++) {\r\n        //getting the shape of the current weights\r\n        let shape = weights[i].shape;\r\n        //making a copy of the raw numbers from the object tensor\r\n        //dataSync gets the numbers, but doesn't make a copy, so slice will make the copy\r\n        let values = weights[i].dataSync().slice();\r\n        for (let j = 0; j &lt; values.length; j++) {\r\n          //if the random number is less than mutation rate the it runs the code\r\n          if (random(1) &lt; rate) {\r\n            this.changeColor = true;\r\n            //mutating the value\r\n            //randomGaussianis returns a float from a series of numbers with a mean of 0\r\n            values[j] = values[j] + randomGaussian();\r\n          }\r\n        }\r\n        //holding the new value of each weight\r\n        mutatedWeights[i] = tf.tensor(values, shape);\r\n      }\r\n      //setting the mutated weights as the new weights\r\n      this.model.setWeights(mutatedWeights);\r\n    });\r\n  }\r\n\r\n  mutated() {\r\n    if (this.changeColor) {\r\n      this.changeColor = false;\r\n      return true;\r\n    } else {\r\n      this.changeColor = false;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  dispose() {\r\n    //disposing the brain so that memory doesn't leak\r\n    this.model.dispose();\r\n  }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 36}]