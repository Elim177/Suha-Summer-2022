[{"items": [{"tags": ["tensorflow", "visualization", "distribution", "tensorboard"], "owner": {"account_id": 10716056, "reputation": 2138, "user_id": 7886651, "user_type": "registered", "accept_rate": 76, "profile_image": "https://i.stack.imgur.com/zfb59.jpg?s=256&g=1", "display_name": "I. A", "link": "https://stackoverflow.com/users/7886651/i-a"}, "is_answered": true, "view_count": 8787, "answer_count": 1, "score": 18, "last_activity_date": 1524813493, "creation_date": 1497234140, "last_edit_date": 1497406358, "question_id": 44490564, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/44490564/interpreting-tensorboard-distributions-weights-not-changing-only-biases", "title": "Interpreting Tensorboard Distributions - Weights not Changing, only Biases", "body": "<p>I have a neural network which is organized as follows: </p>\n\n<pre><code>conv1 - pool1 - local reponse normalization (lrn2) - conv2 - lrn2 - pool2 -\nconv3 - pool3 - conv4 - pool4 - conv5 - pool5 - dense layer (local1) - \nlocal2 - softmax\n</code></pre>\n\n<p>After looking into the tensorboard's distributions, I got the following:</p>\n\n<p><a href=\"https://i.stack.imgur.com/29kbY.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/29kbY.png\" alt=\"conv5_biases\"></a>\n<a href=\"https://i.stack.imgur.com/gHGbt.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/gHGbt.png\" alt=\"conv5_weights\"></a>\n<a href=\"https://i.stack.imgur.com/r6Hdg.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/r6Hdg.png\" alt=\"local1_biases\"></a>\n<a href=\"https://i.stack.imgur.com/8DszD.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/8DszD.png\" alt=\"local1_weights\"></a>\n<a href=\"https://i.stack.imgur.com/ORhTd.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ORhTd.png\" alt=\"local2_weights\"></a>\n<a href=\"https://i.stack.imgur.com/m5V8K.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/m5V8K.png\" alt=\"softmax_weights\"></a>\n<a href=\"https://i.stack.imgur.com/smYPG.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/smYPG.png\" alt=\"Loss\"></a>\nThe following figure are the output of the activations over time. </p>\n\n<p><a href=\"https://i.stack.imgur.com/xkjqQ.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/xkjqQ.png\" alt=\"Conv1 Output Distribution\"></a>\n<a href=\"https://i.stack.imgur.com/QmKK9.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/QmKK9.png\" alt=\"enter image description here\"></a>\n<a href=\"https://i.stack.imgur.com/AkUm4.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/AkUm4.png\" alt=\"enter image description here\"></a>\n<a href=\"https://i.stack.imgur.com/ZgLSN.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ZgLSN.png\" alt=\"enter image description here\"></a>\n<a href=\"https://i.stack.imgur.com/VRzm4.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/VRzm4.png\" alt=\"enter image description here\"></a>\n<a href=\"https://i.stack.imgur.com/GScQn.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/GScQn.png\" alt=\"enter image description here\"></a>\nTherefore, from the loss figure, it is clear that the network is learning. In addition, all of the biases shows as the well that they are modified as a result of learning. But what about the weights, it looks like they haven't changed with time? Is it logical what I am getting from its figures? Please note that I have posted only a subset of the images for the weights and biases in the graph. All weight's figures are similar to what I have presented here, and likewise for the biases <strong>Biases appear to learn, while weights do not!!</strong> </p>\n\n<p>Here is the how I constructed the graph:</p>\n\n<pre><code># Parameters\nlearning_rate = 0.0001\nbatch_size = 1024\nn_classes = 1  # 1 since we need the value of the retrainer.\n\nweights = {\n    'weights_conv1': tf.get_variable(name='weights1', shape=[5, 5, 3, 128], dtype=tf.float32,\n                        initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32)),\n    'weights_conv2': tf.get_variable(name='weights2', shape=[3, 3, 128, 128], dtype=tf.float32,\n                        initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32)),\n    'weights_conv3': tf.get_variable(name='weights3', shape=[3, 3, 128, 256], dtype=tf.float32,\n                        initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32)),\n    'weights_conv4': tf.get_variable(name='weights4', shape=[3, 3, 256, 256], dtype=tf.float32,\n                        initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32)),\n    'weights_conv5': tf.get_variable(name='weights5', shape=[3, 3, 256, 256], dtype=tf.float32,\n                        initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32)),\n}\n\nbiases = {\n    'bc1': tf.Variable(tf.constant(0.1, shape=[128], dtype=tf.float32), trainable=True, name='biases1'),\n    'bc2': tf.Variable(tf.constant(0.1, shape=[128], dtype=tf.float32), trainable=True, name='biases2'),\n    'bc3': tf.Variable(tf.constant(0.1, shape=[256], dtype=tf.float32), trainable=True, name='biases3'),\n    'bc4': tf.Variable(tf.constant(0.1, shape=[256], dtype=tf.float32), trainable=True, name='biases4'),\n    'bc5': tf.Variable(tf.constant(0.1, shape=[256], dtype=tf.float32), trainable=True, name='biases5')\n}\n\ndef inference(frames):\n    # frames = tf.Print(frames, data=[tf.shape(frames)], message='f size is:')\n    tf.summary.image('frame_resized', frames, max_outputs=32)\n    frame_normalized_sub = tf.subtract(frames, tf.constant(128, dtype=tf.float32))\n    frame_normalized = tf.divide(frame_normalized_sub, tf.constant(255.0), name='image_normalization')\n\n    # conv1\n    with tf.name_scope('conv1') as scope:\n        conv_2d_1 = tf.nn.conv2d(frame_normalized, weights['weights_conv1'], strides=[1, 4, 4, 1], padding='SAME')\n        conv_2d_1_plus_bias = tf.nn.bias_add(conv_2d_1, biases['bc1'])\n        conv1 = tf.nn.relu(conv_2d_1_plus_bias, name=scope)\n\n    tf.summary.histogram('con1_output_distribution', conv1)\n    tf.summary.histogram('con1_before_relu', conv_2d_1_plus_bias)\n\n    # norm1\n    with tf.name_scope('norm1'):\n        norm1 = tf.nn.lrn(conv1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='norm1')\n    tf.summary.histogram('norm1_output_distribution', norm1)\n\n    # pool1\n    with tf.name_scope('pool1') as scope:\n        pool1 = tf.nn.max_pool(norm1,\n                               ksize=[1, 3, 3, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='VALID',\n                               name='pool1')\n    tf.summary.histogram('pool1_output_distribution', pool1)\n\n    # conv2\n    with tf.name_scope('conv2') as scope:\n        conv_2d_2 = tf.nn.conv2d(pool1, weights['weights_conv2'], strides=[1, 1, 1, 1], padding='SAME')\n        conv_2d_2_plus_bias = tf.nn.bias_add(conv_2d_2, biases['bc2'])\n        conv2 = tf.nn.relu(conv_2d_2_plus_bias, name=scope)\n\n    tf.summary.histogram('conv2_output_distribution', conv2)\n    tf.summary.histogram('con2_before_relu', conv_2d_2_plus_bias)\n\n    # norm2\n    with tf.name_scope('norm2'):\n        norm2 = tf.nn.lrn(conv2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75,\n                          name='norm2')\n    tf.summary.histogram('norm2_output_distribution', norm2)\n\n    # pool2\n    with tf.name_scope('pool2'):\n        pool2 = tf.nn.max_pool(norm2,\n                               ksize=[1, 3, 3, 1],\n                               strides=[1, 2, 2, 1],\n                               padding='VALID',\n                               name='pool2')\n    tf.summary.histogram('pool2_output_distribution', pool2)\n\n    # conv3\n    with tf.name_scope('conv3') as scope:\n        conv_2d_3 = tf.nn.conv2d(pool2, weights['weights_conv3'], strides=[1, 1, 1, 1], padding='SAME')\n        conv_2d_3_plus_bias = tf.nn.bias_add(conv_2d_3, biases['bc3'])\n        conv3 = tf.nn.relu(conv_2d_3_plus_bias, name=scope)\n\n    tf.summary.histogram('con3_output_distribution', conv3)\n    tf.summary.histogram('con3_before_relu', conv_2d_3_plus_bias)\n\n    # conv4\n    with tf.name_scope('conv4') as scope:\n        conv_2d_4 = tf.nn.conv2d(conv3, weights['weights_conv4'], strides=[1, 1, 1, 1], padding='SAME')\n        conv_2d_4_plus_bias = tf.nn.bias_add(conv_2d_4, biases['bc4'])\n        conv4 = tf.nn.relu(conv_2d_4_plus_bias, name=scope)\n\n    tf.summary.histogram('con4_output_distribution', conv4)\n    tf.summary.histogram('con4_before_relu', conv_2d_4_plus_bias)\n\n    # conv5\n    with tf.name_scope('conv5') as scope:\n        conv_2d_5 = tf.nn.conv2d(conv4, weights['weights_conv5'], strides=[1, 1, 1, 1], padding='SAME')\n        conv_2d_5_plus_bias = tf.nn.bias_add(conv_2d_5, biases['bc5'])\n        conv5 = tf.nn.relu(conv_2d_5_plus_bias, name=scope)\n\n    tf.summary.histogram('con5_output_distribution', conv5)\n    tf.summary.histogram('con5_before_relu', conv_2d_5_plus_bias)\n\n    # pool3\n    pool3 = tf.nn.max_pool(conv5,\n                           ksize=[1, 3, 3, 1],\n                           strides=[1, 2, 2, 1],\n                           padding='VALID',\n                           name='pool5')\n    tf.summary.histogram('pool3_output_distribution', pool3)\n\n    # local1\n    with tf.variable_scope('local1') as scope:\n        # Move everything into depth so we can perform a single matrix multiply.\n        shape_d = pool3.get_shape()\n        shape = shape_d[1] * shape_d[2] * shape_d[3]\n        # tf_shape = tf.stack(shape)\n        tf_shape = 1024\n\n        print(\"shape:\", shape, shape_d[1], shape_d[2], shape_d[3])\n\n        reshape = tf.reshape(pool3, [-1, tf_shape])\n        weight_local1 = \\\n            tf.get_variable(name='weight_local1', shape=[tf_shape, 2046], dtype=tf.float32,\n                            initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32))\n        bias_local1 = tf.Variable(tf.constant(0.1, tf.float32, [2046]), trainable=True, name='bias_local1')\n        local1_before_relu = tf.matmul(reshape, weight_local1) + bias_local1\n        local1 = tf.nn.relu(local1_before_relu, name=scope.name)\n\n    tf.summary.histogram('local1_output_distribution', local1)\n    tf.summary.histogram('local1_before_relu', local1_before_relu)\n\n    tf.summary.histogram('local1_weights', weight_local1)\n    tf.summary.histogram('local1_biases', bias_local1)\n\n    # local2\n    with tf.variable_scope('local2') as scope:\n        # Move everything into depth so we can perform a single matrix multiply.\n        weight_local2 = \\\n            tf.get_variable(name='weight_local2', shape=[2046, 2046], dtype=tf.float32,\n                            initializer=tf.contrib.layers.xavier_initializer_conv2d(uniform=False, dtype=tf.float32))\n        bias_local2 = tf.Variable(tf.constant(0.1, tf.float32, [2046]), trainable=True, name='bias_local2')\n        local2_before_relu = tf.matmul(local1, weight_local2) + bias_local2\n        local2 = tf.nn.relu(local2_before_relu, name=scope.name)\n\n    tf.summary.histogram('local2_output_distribution', local2)\n    tf.summary.histogram('local2_before_relu', local2_before_relu)\n\n    tf.summary.histogram('local2_weights', weight_local2)\n    tf.summary.histogram('local2_biases', bias_local2)\n\n    # linear Wx + b\n    with tf.variable_scope('softmax_linear') as scope:\n        weight_softmax = \\\n            tf.Variable(\n                tf.truncated_normal([2046, n_classes], stddev=1 / 1024, dtype=tf.float32), name='weight_softmax')\n        bias_softmax = tf.Variable(tf.constant(0.0, tf.float32, [n_classes]), trainable=True, name='bias_softmax')\n        softmax_linear = tf.add(tf.matmul(local2, weight_softmax), bias_softmax, name=scope.name)\n\n    tf.summary.histogram('softmax_output_distribution', softmax_linear)\n    tf.summary.histogram('softmax_weights', weight_softmax)\n    tf.summary.histogram('softmax_biases', bias_softmax)\n\n    tf.summary.histogram('weights_conv1', weights['weights_conv1'])\n    tf.summary.histogram('weights_conv2', weights['weights_conv2'])\n    tf.summary.histogram('weights_conv3', weights['weights_conv3'])\n    tf.summary.histogram('weights_conv4', weights['weights_conv4'])\n    tf.summary.histogram('weights_conv5', weights['weights_conv5'])\n\n    tf.summary.histogram('biases_conv1', biases['bc1'])\n    tf.summary.histogram('biases_conv2', biases['bc2'])\n    tf.summary.histogram('biases_conv3', biases['bc3'])\n    tf.summary.histogram('biases_conv4', biases['bc4'])\n    tf.summary.histogram('biases_conv5', biases['bc5'])\n\n    return softmax_linear\n\n# Note that this is the RMSE\nwith tf.name_scope('loss'):\n    # Note that the dimension of cost is [batch_size, 1]. Every example has one output and a batch\n    # is a number of examples.\n    cost = tf.sqrt(tf.square(tf.subtract(predictions, y_valence)))\n    cost_scalar = tf.reduce_mean(tf.multiply(cost, confidence_holder), reduction_indices=0)\n    # Till here cost_scolar will have the following shape: [[#num]]... That is why I used cost_scalar[0]\n    tf.summary.scalar(\"loss\", cost_scalar[0])\n\nwith tf.name_scope('train'):\n    optimizer = tf.train.AdamOptimizer(learning_rate).minimize(cost_scalar)\n</code></pre>\n\n<p>Any help is much appreciated!!</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 74}]