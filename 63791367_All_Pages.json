[{"items": [{"tags": ["python", "tensorflow"], "owner": {"user_type": "does_not_exist", "display_name": "user14240528"}, "is_answered": false, "view_count": 162, "answer_count": 1, "score": 0, "last_activity_date": 1599569833, "creation_date": 1599558548, "question_id": 63791367, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/63791367/how-to-initialize-an-identity-matrix-in-tensorflow-with-no-specified-parameters", "title": "How to initialize an identity matrix in tensorflow with no specified parameters?", "body": "<p>I am trying to implement part of the code on Graph Convolutional Networks given in this <a href=\"https://www.experoinc.com/post/node-classification-by-graph-convolutional-network\" rel=\"nofollow noreferrer\">article</a>. I notice that the author uses tf.eye() with no shape parameter. When I tried to rerun the same code, using tensorflow 1, it gave me the expected error that <code>TypeError: eye() missing 1 required positional argument: 'num_rows'</code>\nCan someone explain how the <code>tf.eye()</code> in the article works and/or if there was another way to initialize an identity matrix with unspecified shape?\nHere is the code (compatible with tensorflow 1 coz apprently tensorflow2 doesn't have <code>tf.placeolder()</code>)</p>\n<pre><code>import numpy as np\nimport networkx as nx\nimport tensorflow as tf\nfeatures=  tf.placeholder(tf.float32, shape=[None, 2])\nadjacency=  tf.placeholder(tf.float32, shape=[None, 2])\ndegree=  tf.placeholder(tf.float32, shape=[None, 2])\nlabels=  tf.placeholder(tf.float32, shape=[None, 2])\nweights= tf.Variable(tf.random.normal([], 0, 1, tf.float32, seed=1))\ndef layer(features, adjacency, degree, weights):\n    with tf.name_scope('gcn_layer'):\n        d_ =tf.pow(degree + tf.eye(), -0.5)\n        y = tf.matmul(d_, tf.matmul(adjacency, d_))\n        kernel = tf.matmul(features, weights)\n        \n        return tf.nn.relu(tf.matmul(y,kernel))\n    \nmodel = layer(features, adjacency, degree, weights)    \n    \nwith tf.name_scope('loss'):\n        loss =tf.reduce_mean(\n            tf.nn.somftmax_crosse_ntropy_with_logits(\n                                logits=model, labels=labels))\n        train_op=train.AdamOptimizer(0.001, 0.9).minimize(loss)\n        \nwith tf.Session() as sess:\n    sess.run(train_op, feed_dict={\n        features:features, adjacency:adjacency, degree:degree, labels:labels})\n</code></pre>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 61}]