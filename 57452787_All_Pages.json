[{"items": [{"tags": ["python", "tensorflow", "keras", "loss-function", "svd"], "owner": {"account_id": 9968983, "reputation": 2869, "user_id": 7375754, "user_type": "registered", "accept_rate": 77, "profile_image": "https://www.gravatar.com/avatar/830f6d236ab0502a68fd9b9daf7f729f?s=256&d=identicon&r=PG&f=1", "display_name": "Jane Sully", "link": "https://stackoverflow.com/users/7375754/jane-sully"}, "is_answered": true, "view_count": 3190, "answer_count": 1, "score": 1, "last_activity_date": 1565558585, "creation_date": 1565550230, "last_edit_date": 1565552348, "question_id": 57452787, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/57452787/tensor-objects-are-only-iterable-when-eager-execution-is-enabled-error-when-tr", "title": "&quot;Tensor objects are only iterable when eager execution is enabled&quot; error when trying to create custom loss function in Keras", "body": "<p>I am trying to do SVD using a neural network. My input is a matrix (let's say 4x4 matrices only) and the output is a vector representing the decomposed form (given that the input is 4x4 this would be a 36 element vector with 16 elements for U, 4 elements for S, and 16 elements for V.T). </p>\n\n<p>I am trying to define a custom loss function instead of using something like MSE on the decomposed form. So instead of comparing the 36 length vectors for loss, I want to compute the loss between the reconstructed matrices. So if <code>A = U * S * V.T</code> (actual) and <code>A' = U' * S' * V.T'</code> (predicted), I want to compute the loss between A and A'. </p>\n\n<p>I am pretty new to tensorflow and keras, so I may be doing some naive things, but here is what I have so far. While the logic seems okay to me, I get a <code>TypeError: Tensor objects are only iterable when eager execution is enabled. To iterate over this tensor use tf.map_fn.</code> I am not sure why this is the case and how to fix it? Also, do I need to flatten the output from the <code>reconstruct_matrix</code>, as I am currently doing, or should I just leave it as is?</p>\n\n<pre><code># This function takes the decomposed matrix (vector of U, S, V.T)\n# and reconstructs the original matrix\n\ndef reconstruct_matrix(decomposed_vector):\n  example = decomposed_vector\n  s = np.zeros((4,4))\n  for en, i in enumerate(example[16:20]):\n    s[en, en] = i\n  u = example[:16].reshape(4,4)\n  vt = example[20:].reshape(4,4)\n  orig = np.matmul(u, s)\n  orig = np.matmul(orig, vt)\n  return orig.flatten() # Given that matrices are 4x4, this will be a length 16 vector\n\n# Custom loss that essentially computes MSE on reconstructed matrices \n\ndef custom_loss(y_true, y_pred):\n    Y = reconstruct_matrix(y_true)\n    Y_prime = reconstruct_matrix(y_pred)\n    return K.mean(K.square(Y - Y_prime)) \n\nmodel.compile(optimizer='adam',\n              loss=custom_loss)\n</code></pre>\n\n<p>Note: My keras version is 2.2.4 and my tensorflow version is 1.14.0.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 39}]