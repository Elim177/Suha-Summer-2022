[{"items": [{"tags": ["python", "tensorflow"], "owner": {"account_id": 1913456, "reputation": 331, "user_id": 1726633, "user_type": "registered", "accept_rate": 60, "profile_image": "https://www.gravatar.com/avatar/cd298e702bbaa223ddf3607ba68bc64d?s=256&d=identicon&r=PG", "display_name": "user1726633", "link": "https://stackoverflow.com/users/1726633/user1726633"}, "is_answered": false, "view_count": 260, "answer_count": 0, "score": 0, "last_activity_date": 1516275083, "creation_date": 1516275083, "question_id": 48320301, "content_license": "CC BY-SA 3.0", "link": "https://stackoverflow.com/questions/48320301/tensorflow-segment-addition", "title": "Tensorflow segment addition", "body": "<p>Let's say I have a tensor C of shape (T,78,S). The 78 floats along axis 1 represent groups of 34 payments P with shape (T,34,S). T>=1, S>=1.</p>\n\n<p>The exact grouping and its start index is known e.g. </p>\n\n<pre><code>group = array([3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 2], dtype=int64)\ncash_index = array([ 0,  3,  5,  8, 10, 12, 14, 16, 18, 21, 23, 26, 28, 31, 33, 35, 37, 39, 41, 43, 45, 48, 50, 53, 55, 58, 60, 62, 64, 66, 68, 71, 73, 76], dtype=int64)\n</code></pre>\n\n<p>Using this grouping it's relatively easy to work out how to use tf.segment_sum to sum these payments i.e.</p>\n\n<pre><code>cash_group = array([ 0,  0,  0,  1,  1,  2,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,\n    7,  8,  8,  8,  9,  9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14,\n   14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 21, 21, 22,\n   22, 22, 23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29,\n   30, 30, 30, 31, 31, 32, 32, 32, 33, 33], dtype=int64)\n</code></pre>\n\n<p>But since tf.segment_sum only works on the first axis, I have to transpose C first, take the segment_sum, and then transpose it back. Is there a faster way to do this? An axis= parameter to segment_sum would really help.</p>\n\n<p>Also, let's say I need to accumulate a value for each payment. </p>\n\n<pre><code>total       = tf.zeros_like(P, dtype=tf.float32)\nmin_group   = group.min()\n\nfor i in range(min_group):\n    offst = cash_index+i\n    int_i = tf.gather(C,offst,axis=1)\n    total += (total+Nominal[offst])*int_i\n</code></pre>\n\n<p>Here Nominal is just a simple numpy array of size 78. This works perfectly when all the groups are the same size (e.g. 2) but will be wrong with the example given. To fix this, I've tried the following:</p>\n\n<pre><code>offst = min_group+cash_index[group&gt;min_group]\ndest  = np.arange(cash_index.size)[group&gt;min_group]\nint_i = tf.gather(C,offst,axis=1)\n\ntotal = tf.scatter_add(total, dest, (tf.gather(total,dest,axis=1)+Nominal[offst])*int_i)\n</code></pre>\n\n<p>Which fails with</p>\n\n<pre><code>TypeError: 'ScatterAdd' Op requires that input 'ref' be a mutable tensor (e.g.: a tf.Variable)\n</code></pre>\n\n<p>How do I fix this? Is there a better way to perform the accumulation? \nThanks.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 86}]