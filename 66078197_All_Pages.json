[{"items": [{"tags": ["python", "keras", "generator", "tensorflow2.0", "tf.keras"], "owner": {"account_id": 16546644, "reputation": 33, "user_id": 11956015, "user_type": "registered", "profile_image": "https://graph.facebook.com/885881928446209/picture?type=large", "display_name": "Serj Ionescu", "link": "https://stackoverflow.com/users/11956015/serj-ionescu"}, "is_answered": true, "view_count": 402, "accepted_answer_id": 66079979, "answer_count": 1, "score": 1, "last_activity_date": 1612635483, "creation_date": 1612623224, "question_id": 66078197, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/66078197/passing-a-keras-generator-to-call-method-of-my-model", "title": "Passing a Keras Generator to __call__ method of My Model", "body": "<p>I have written my own keras Model, and I'm trying to pass a Keras Generator as input to model.fit.\nThe problem is that I don't know how to process the generator, when I'm in the <strong>call</strong> method of MyModel. How do I access the x and y from the generator in order to pass them as inputs to my Encoder and Decoder Network, and also keep the generator working its magic, loading the batches each epoch ?</p>\n<p>Ok so this MyModel class which inherits tf.keras.Model</p>\n<pre><code>class MyModel(tf.keras.Model):\n\ndef __init__(self):\n    super(MyModel, self).__init__()\n    self.enc = Encoder()\n    self.dec1 = Decoder1()\n    self.dec2 = Decoder2()\n\ndef __call__(self, data_generator, **kwargs):\n\n    ################################################ \n    ? how do I acces x and y in order to pass them to the encoder and decoder ? \n    and also keep the generator proprieties\n    ###############################################\n    x_train, y_train = data_generator # ?????????\n    #####################################\n\n    dec_inputs = tf.concat((tf.zeros_like(y_train[:, :1, :]), y_train[:, :-1, :]), 1)  \n                                                                                      \n    dec_inputs = dec_inputs[:, :, -hp.n_mels:] \n\n    print(&quot;########ENC INPUTS #####&quot;)\n    #print(tf.shape(x_train))\n    print(&quot;######################&quot;)\n\n    print(&quot;#########DEC INPUTS #####&quot;)\n    #print(tf.shape(dec_inputs))\n    print(&quot;######################&quot;)\n\n    memory = self.enc(x_train)\n    y_hat = self.dec1(dec_inputs, memory)\n    #z_hat = self.dec2(y_hat)\n    return y_hat\n</code></pre>\n<p>And this is my generator function</p>\n<pre><code>class DataGenerator(keras.utils.Sequence):\n\ndef __init__(self, list_IDs, ID_dictionary, labels, batch_size=8, dim1=(32, 32, 32), dim2=(32, 32, 32),\n             n_channels=None, n_classes=None, shuffle=True):\n    'Initialization'\n\n    self.dim1 = dim1  # dimensiune X\n    self.dim2 = dim2  # dimensiune Y\n    self.batch_size = batch_size\n\n    self.ID_dictionary = ID_dictionary\n    self.labels = labels\n    self.list_IDs = list_IDs\n\n    self.n_channels = n_channels\n    self.n_classes = n_classes\n\n    self.shuffle = shuffle\n    self.on_epoch_end()\n\ndef __len__(self):\n    'Denotes the number of batches per epoch'\n    return int(np.floor(len(self.list_IDs) / self.batch_size))\n\n# 3\ndef __getitem__(self, index):\n    'Generate one batch of data'\n    # Generate indexes of the batch\n    indexes = self.indexes[index * self.batch_size:(index + 1) * self.batch_size] \n\n    # Find list of IDs\n    list_IDs_temp = [self.list_IDs[k] for k in indexes]         \n\n    # Generate data\n    x, y = self.__data_generation(list_IDs_temp)  \n\n    return x, y\n\n# 1\ndef on_epoch_end(self):\n    'Updates indexes after each epoch'\n    self.indexes = np.arange(len(self.list_IDs))  \n    if self.shuffle == True:\n        np.random.shuffle(self.indexes)\n\n# 2\ndef __data_generation(self, list_IDs_temp):\n    # Initialization            \n    x = np.empty((self.batch_size, self.dim1)) \n    y = np.empty((self.batch_size, *self.dim2), dtype=float)\n\n    # Generate data\n    for i, ID in enumerate(list_IDs_temp):  \n        # Store sample\n        x[i, ] = self.ID_dictionary[ID]       \n        # Store class\n        y[i] = self.labels[ID]                  \n    return x, y\n</code></pre>\n\n<p>And this is how I call MyModel in main</p>\n<pre><code> listID, dict1, dict2, text_shape, mel_shape = get_batch()\n # dict1 has the inputs ( text ) and dict2 has the labels ( the mels )\n \n training_generator = DataGenerator(listID, dict1, dict2, dim1=text_shape, dim2=mel_shape)\n\n model = MyModel()\n\n\n model.compile(\n      optimizer=keras.optimizers.Adam(),\n      metrics=[&quot;accuracy&quot;],\n\n      )\n\n  #model.fit_generator(generator=training_generator, use_multiprocessing=True, workers=6)\n  model.fit(training_generator, epochs=2)\n</code></pre>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 217}]