[{"items": [{"tags": ["python-3.x", "tensorflow", "tensorflow2.0"], "owner": {"account_id": 285031, "reputation": 5218, "user_id": 583464, "user_type": "registered", "accept_rate": 87, "profile_image": "https://www.gravatar.com/avatar/931448dc20c10c1b799bb9dba38b5e58?s=256&d=identicon&r=PG", "display_name": "George", "link": "https://stackoverflow.com/users/583464/george"}, "is_answered": true, "view_count": 9055, "accepted_answer_id": 55172149, "answer_count": 1, "score": 3, "last_activity_date": 1624603045, "creation_date": 1552563460, "question_id": 55161550, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/55161550/valuerror-attemp-to-convert-a-value-type-model-to-a-tensor", "title": "valuerror attemp to convert a value (type model) to a tensor", "body": "<p>I am trying to train a model using tensorflow 2.</p>\n\n<p>I am receiving the error:</p>\n\n<pre><code>ValueError: Attempt to convert a value (&lt;tensorflow.python.keras.engine.training.Model object at 0x7f1ab822ecc0&gt;) with an unsupported type (&lt;class 'tensorflow.python.keras.engine.training.Model'&gt;) to a Tensor.\n</code></pre>\n\n<p>when I try to call </p>\n\n<p><code>return loss_object(y_true=y, y_pred=ypred)</code></p>\n\n<p>inside the <code>loss</code> function.</p>\n\n<p>The type of <code>ypred</code> is </p>\n\n<p><code>&lt;class'tensorflow.python.keras.engine.training.Model'&gt;</code></p>\n\n<p>It should be a tensor though.</p>\n\n<pre><code>import tensorflow as tf\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\n\n\ndf = pd.DataFrame({'A': np.array([100, 105.4, 108.3, 111.1, 113, 114.7]),\n                   'B': np.array([11, 11.8, 12.3, 12.8, 13.1,13.6]),\n                   'C': np.array([55, 56.3, 57, 58, 59.5, 60.4]),\n                   'Target': np.array([4000, 4200.34, 4700, 5300, 5800, 6400])})\n\n\n\ndef data():\n    X_train, X_test, y_train, y_test  = train_test_split(df.iloc[:, :3].values,\n                                                         df.iloc[:, 3].values,\n                                                         test_size=0.2,\n                                                         random_state=134)\n\n    return X_train, X_test, y_train, y_test\n\n\n\nX_train, X_test, y_train, y_test = data()\n\n\n\nfeatures = {'A': X_train[:, 0],\n            'B': X_train[:, 1],\n            'C': X_train[:, 2]}\n\nlabels = y_train\n\n\nbatch_size = 1\ndef train_input_fn(features, labels, batch_size):\n    train_dataset = tf.data.Dataset.from_tensor_slices((dict(features), labels))\n    train_dataset = train_dataset.shuffle(1000).repeat().batch(batch_size)\n    return train_dataset\n\n\ndef pack_features_vector(features, labels):\n    '''Pack the features into a single array'''\n    features = tf.stack(list(features.values()), axis=1)\n    return features, labels\n\n\ntrain_dataset = train_input_fn(features, labels, batch_size).map(pack_features_vector)\n\n\nclass Model():\n\n    def __init__(self):\n        pass\n\n    def build_model(self, features):\n        inputs = tf.keras.Input(shape=(features.shape[1],))\n\n        x = tf.keras.layers.Dense(2, activation='relu')(inputs)\n        preds = tf.keras.layers.Dense(1)(x)\n\n        model = tf.keras.Model(inputs=inputs, outputs=preds)\n\n        return model\n\n    def loss(self, loss_object, X, y):\n        ypred = self.build_model(X)\n        print(type(ypred))\n        print(ypred)\n        return loss_object(y_true=y, y_pred=ypred)\n\n    def grad(self, loss_object, X, y):\n        with tf.GradientTape() as tape:\n            loss_value = self.loss(loss_object, X, y)\n        return loss_value, tape.gradient(loss_value,  self.build_model(X).trainable_variables)\n\n    def train(self, X, y, optimizer, loss_object):\n        loss_value, grads = self.grad(loss_object,  X, y)\n        optimizer.apply_gradients(zip(grads,  self.build_model(X).trainable_variables))\n\n\nlearning_rate = 0.001\noptimizer=tf.optimizers.RMSprop(learning_rate)\nloss_object=tf.keras.losses.mean_squared_error\n\n\nepochs = 1\n\nfor epoch in range(epochs):\n    epoch_loss_avg = tf.keras.metrics.Mean()\n    epoch_acc = tf.keras.metrics.MeanSquaredError()\n\n    for X, y in train_dataset:\n        Model().train(X, y, optimizer, loss_object)  \n</code></pre>\n\n<p>If I don't use the class and run instead:</p>\n\n<pre><code>inputs = tf.keras.Input(shape=(3,))\n\nx = tf.keras.layers.Dense(2, activation='relu')(inputs)\n\npreds = tf.keras.layers.Dense(1)(x)\n\nmodel = tf.keras.Model(inputs=inputs, outputs=preds)\n\nfor x, y in train_dataset:\n    ypred = model(x)\n    print(type(ypred))\n    loss_object(y, ypred)\n</code></pre>\n\n<p>it runs ok!</p>\n\n<p>The type of <code>model(x)</code> is <code>&lt;class 'tensorflow.python.framework.ops.EagerTensor'&gt;</code></p>\n\n<p>but in the class code, the type of <code>self.build_model(X)</code> is <code>model</code>.</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 270}]