[{"items": [{"tags": ["python", "arrays", "tensorflow"], "owner": {"account_id": 18387461, "reputation": 584, "user_id": 13614416, "user_type": "registered", "profile_image": "https://i.stack.imgur.com/Hlbol.jpg?s=256&g=1", "display_name": "spiridon_the_sun_rotator", "link": "https://stackoverflow.com/users/13614416/spiridon-the-sun-rotator"}, "is_answered": true, "view_count": 381, "accepted_answer_id": 67182373, "answer_count": 1, "score": 1, "last_activity_date": 1618934353, "creation_date": 1618932939, "last_edit_date": 1618933355, "question_id": 67182034, "content_license": "CC BY-SA 4.0", "link": "https://stackoverflow.com/questions/67182034/more-efficient-way-to-create-a-mask-of-top-k-elements-in-tensorflow", "title": "More efficient way to create a mask of top `k` elements in tensorflow", "body": "<p>I would like to create a function, that for a given <code>1d</code>-tensor outputs the mask, where on the places, corresponding to the top <code>k</code> values there are <code>1</code> and <code>0</code> elsewhere.\nNamely, I have for example:</p>\n<pre><code>tensor = [1, 0, 7, 5, 2, 3] : get_largest_mask(tensor, 3) = [0, 0, 1, 1, 0, 1]\n</code></pre>\n<p>I've created the following function:</p>\n<pre><code>def get_largest_mask(tensor, n_to_keep):\n    # tensor 1-d tensor\n    values, indices = tf.math.top_k(tensor, k=n_to_keep)\n\n    mask = tf.zeros(tf.size(tensor))\n    mask = tf.tensor_scatter_nd_update(mask, [[idx] for idx in indices], tf.ones(n_to_keep))\n\n    return mask\n</code></pre>\n<p>However for the case of interest it works rather slowly, and as I've measured most of the time is dominated by <code>tf.tensor_scatter_nd_update</code>. What would be the faster alternative?</p>\n<p>The typical size of tensor is <code>10^3-10^4</code> elements and <code>k</code> is of order `10^2-10^3'</p>\n"}], "has_more": false, "quota_max": 300, "quota_remaining": 161}]